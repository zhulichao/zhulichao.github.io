<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端学习之路</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhulichao.github.io/"/>
  <updated>2021-11-30T02:58:48.060Z</updated>
  <id>https://zhulichao.github.io/</id>
  
  <author>
    <name>小朱</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS 基础</title>
    <link href="https://zhulichao.github.io/2021/06/11/css-fj/"/>
    <id>https://zhulichao.github.io/2021/06/11/css-fj/</id>
    <published>2021-06-11T09:03:52.000Z</published>
    <updated>2021-11-30T02:58:48.060Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="BFC（块级格式化上下文）"><a href="#BFC（块级格式化上下文）" class="headerlink" title="BFC（块级格式化上下文）"></a>BFC（块级格式化上下文）</h2><p>块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则，可用于清除浮动，防止 margin 重叠等。</p>
<ul>
<li>BFC 区域不会与浮动元素重叠，浮动元素也會参与高度计算</li>
<li>BFC 是页面上的一个独立容器，子元素不会影响到外面</li>
<li>哪些元素会生成 BFC<ul>
<li>根元素</li>
<li>float 不为 none 的元素</li>
<li>position 为 fixed 和 absolute 的元素</li>
<li>display 为 inline-block、table-cell、table-caption，flex，inline-flex 的元素</li>
<li>overflow 不为 visible 的元素</li>
</ul>
</li>
</ul>
<h2 id="overflow-的原理"><a href="#overflow-的原理" class="headerlink" title="overflow 的原理"></a>overflow 的原理</h2><p>要讲清楚这个解决方案的原理，首先需要了解块格式化上下文。块格式化上下文是 CSS 可视化渲染的一部分，它是一块区域，规定了内部块的渲染方式，以及浮动相互之间的影响关系，当元素设置了 overflow 样式且值不为 visible 时，该元素就构建了一个 BFC，BFC 在计算高度时，内部浮动元素的高度也要计算在内，也就是说即使 BFC 区域内只有一个浮动元素，BFC 的高度也不会发生塌缩，所以达到了清除浮动的目的。</p>
<h2 id="垂直居中的方法"><a href="#垂直居中的方法" class="headerlink" title="垂直居中的方法"></a>垂直居中的方法</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">img</span> &#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">margin</span>: auto;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.inner</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">480px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">380px</span>;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">margin-top</span>: -<span class="number">190px</span>; <span class="comment">/*height 的一半，也可以用 transform：translateY(-50%) */</span>  </div><div class="line">  <span class="attribute">margin-left</span>: -<span class="number">240px</span>; <span class="comment">/*width 的一半，也可以用 transform：translateX(-50%) */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.parent</span> &#123;</div><div class="line">  <span class="attribute">display</span>: table-cell;</div><div class="line">   <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.parent</span> &#123;</div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">  <span class="attribute">justify-content</span>: center;</div><div class="line">  <span class="attribute">align-items</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="说一下块元素和行元素"><a href="#说一下块元素和行元素" class="headerlink" title="说一下块元素和行元素"></a>说一下块元素和行元素</h2><p>块元素：独占一行，并且有自动填满父元素，可以设置 margin 和 padding 以及高度和宽度<br>行元素：不会独占一行，width 和 height 会失效，并且在垂直方向的 padding 和 margin 会失效</p>
<h2 id="visibility-hidden-opacity-0，display-none"><a href="#visibility-hidden-opacity-0，display-none" class="headerlink" title="visibility=hidden, opacity=0，display:none"></a>visibility=hidden, opacity=0，display:none</h2><ul>
<li><code>opacity=0</code> 该元素隐藏起来了，但不会改变页面布局，会触发该元素已经绑定的事件</li>
<li><code>visibility=hidden</code> 该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件</li>
<li><code>display=none</code> 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样</li>
</ul>
<h2 id="float-的元素-display-是什么值"><a href="#float-的元素-display-是什么值" class="headerlink" title="float 的元素 display 是什么值"></a>float 的元素 display 是什么值</h2><p>float 的元素，display 是 block。</p>
<h2 id="z-index-的定位方法"><a href="#z-index-的定位方法" class="headerlink" title="z-index 的定位方法"></a>z-index 的定位方法</h2><p>z-index 属性设置元素的堆叠顺序，拥有更好堆叠顺序的元素会处于较低顺序元素之前， z-index 可以为负，且 z-index 只能在定位元素上奏效，该属性设置一个定位元素沿 z 轴的位置，如果为正数，离用户越近，为负数，离用户越远，它的属性值有 auto（默认，堆叠顺序与父元素相等），number，inherit（从父元素继承 z-index 属性的值）。</p>
<h2 id="了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法"><a href="#了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法" class="headerlink" title="了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法"></a>了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法</h2><p>DOM 的变化影响到了预算内宿的几何属性比如宽高，浏览器重新计算元素的几何属性， 其他元素的几何属性也会受到影响，浏览器需要重新构造渲染书，这个过程称之为重排， 浏览器将受到影响的部分重新绘制在屏幕上 的过程称为重绘，引起重排重绘的原因有： 添加或者删除可见的 DOM 元素， 元素尺寸位置的改变 浏览器页面初始化， 浏览器窗口大小发生改变，重排一定导致重绘，重绘不一定导致重排， 减少重绘重排的方法有： 不在布局信息改变时做 DOM 查询， 使用 csstext,className 一次性改变属性 使用 fragment 对于多次重排的元素，比如说动画。使用绝对定位脱离文档流，使其不影响其他元素</p>
<h2 id="js-动画-和-css-动画的区别"><a href="#js-动画-和-css-动画的区别" class="headerlink" title="js 动画 和 css 动画的区别"></a>js 动画 和 css 动画的区别</h2><h3 id="js-动画"><a href="#js-动画" class="headerlink" title="js 动画"></a>js 动画</h3><p>首先，js动画是逐帧动画，几乎可以完成您想要的任何动画形式。但因为内容不同会增加生产负担，并且资源占用相对较大。但是它的优点也很明显：非常适合执行非常精致的动画，例如3D效果，人物或动物的急转弯等。但是，如果帧速率太低，则从一个帧到另一个帧的过渡很可能是不自然且不一致的。</p>
<p>缺点：</p>
<ul>
<li>JavaScript在浏览器的主线程中运行，还有其他JavaScript脚本、样式计算、布局、绘图任务需要在主线程中运行。干扰它们可能导致线程阻塞，从而导致帧丢失。</li>
<li>代码复杂度高于CSS动画。</li>
</ul>
<p>优点：</p>
<ul>
<li>JavaScript动画控制能力很强，可以控制动画在播放过程中：开始、暂停、播放、终止、取消都可以完成。</li>
<li>动画效果比CSS3动画更丰富，一些动画效果，如曲线运动、冲击闪烁、视差滚动等效果，只有JavaScript动画才能完成。</li>
<li>CSS3有兼容性问题，而JS大多数时候没有兼容性问题。</li>
</ul>
<h3 id="css-动画"><a href="#css-动画" class="headerlink" title="css 动画"></a>css 动画</h3><p>动画是使元素从一种样式逐渐变化为另一种样式的效果。当实现一些简单的滑动，翻转和其他特殊效果时，Css3非常方便，但是当你想要实现一些很酷的效果时，它的操作通常比js操作具有更多的冗余。</p>
<p>缺点：</p>
<ul>
<li>运行过程的控制较弱，不可能附加事件绑定回调函数。 CSS动画只能暂停，无法在动画中找到特定的时间点，不能中途反转动画，无法更改时间比例，无法添加回调函数或将播放事件绑定到特定位置，并且没有进度报告</li>
<li>代码冗长。 如果您想使用CSS来实现稍微复杂一点的动画，那么CSS代码最终将变得非常繁琐。</li>
</ul>
<p>优点：</p>
<ul>
<li>浏览器可以优化动画。</li>
<li>代码相对简单，并且性能调整方向是固定的。</li>
<li>对于帧速率性能较差的低版本浏览器，CSS3可以自然降级，而JS需要编写其他代码。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
      <category term="FJ" scheme="https://zhulichao.github.io/categories/FJ/"/>
    
    
      <category term="FJ" scheme="https://zhulichao.github.io/tags/FJ/"/>
    
  </entry>
  
  <entry>
    <title>Web 基础</title>
    <link href="https://zhulichao.github.io/2021/06/09/http-html-browser/"/>
    <id>https://zhulichao.github.io/2021/06/09/http-html-browser/</id>
    <published>2021-06-09T01:34:24.000Z</published>
    <updated>2021-11-30T02:58:48.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="click-在-ios-上有-300ms-延迟，原因及如何解决"><a href="#click-在-ios-上有-300ms-延迟，原因及如何解决" class="headerlink" title="click 在 ios 上有 300ms 延迟，原因及如何解决"></a>click 在 ios 上有 300ms 延迟，原因及如何解决</h2><p>问题：双击缩放(double tap to zoom)，是会有 300 毫秒延迟的主要原因。当用户一次点击屏幕之后，浏览器并不能立刻判断用户是要进行双击缩放，还是想要进行单击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。</p>
<p>解决方案：</p>
<ul>
<li>使用 <a href="https://github.com/ftlabs/fastclick" target="_blank" rel="external">FastClick</a> 库，FastClick 在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即触发一个模拟click 事件的click事件（自定义事件），并把浏览器在 300 毫秒之后真正触发的 click 事件阻止掉。</li>
<li>禁用缩放。<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=no&quot;&gt;</code></li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>强缓存：从缓存取，状态码为 200，不发送请求到服务器。相关字段 expires、cache-control，cache-control 优先级高</p>
<p>协商缓存：从缓存取，状态码为 304，发送请求到服务器。相关字段 Last-Modified/If-Modified-Since，Etag/If-None-Match</p>
<p><a href="https://segmentfault.com/a/1190000008956069" target="_blank" rel="external">HTTP强缓存和协商缓存</a></p>
<h2 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h2><ul>
<li>减少 HTTP 请求数量</li>
<li>minify / gzip 压缩</li>
<li>lazyLoad</li>
<li>预解析 DNS</li>
<li>使用 CDN</li>
<li>缓存</li>
<li>加载顺序优化</li>
<li>服务端渲染</li>
</ul>
<h2 id="输入-URL-到页面至加载显示完成，发生了什么"><a href="#输入-URL-到页面至加载显示完成，发生了什么" class="headerlink" title="输入 URL 到页面至加载显示完成，发生了什么?"></a>输入 URL 到页面至加载显示完成，发生了什么?</h2><ul>
<li>DNS 解析：浏览器缓存 -&gt; 系统缓存 -&gt; 路由器缓存 -&gt; hosts 文件 -&gt; DNS 服务器，得到服务器的 ip 地址</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面：构建 DOM 树，在 DOM 树的构建过程中如果遇到 JS 脚本和外部 JS 连接，则会停止构建 DOM 树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐 JS 代码应该放在 html 代码的后面；构建 CSSOM 树；合并为渲染树，渲染页面；解析 DOM 过程中如果遇到图片、视频、音频等资源，会并行下载</li>
<li>连接结束</li>
</ul>
<h2 id="什么时候用-304？"><a href="#什么时候用-304？" class="headerlink" title="什么时候用 304？"></a>什么时候用 304？</h2><p>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个 304 状态码。</p>
<h2 id="link-标签和-import-标签的区别"><a href="#link-标签和-import-标签的区别" class="headerlink" title="link 标签和 import 标签的区别"></a>link 标签和 import 标签的区别</h2><ul>
<li>link 属于 html 标签，因此没有兼容性，而@import 是 css 提供的，只有 IE5 以上才能识别</li>
<li>link 方式样式的权重高于 @import 的</li>
<li>页面被加载时，link 会同时被加载，而@import 引用的 css 会等到页面加载结束后加载</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
      <category term="FJ" scheme="https://zhulichao.github.io/categories/FJ/"/>
    
    
      <category term="FJ" scheme="https://zhulichao.github.io/tags/FJ/"/>
    
  </entry>
  
  <entry>
    <title>JS 基础</title>
    <link href="https://zhulichao.github.io/2021/06/04/sohu-web/"/>
    <id>https://zhulichao.github.io/2021/06/04/sohu-web/</id>
    <published>2021-06-04T09:10:03.000Z</published>
    <updated>2021-11-30T02:58:48.057Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="自己实现一个-bind-函数"><a href="#自己实现一个-bind-函数" class="headerlink" title="自己实现一个 bind 函数"></a>自己实现一个 bind 函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">obj, ...arg</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> context = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span> (<span class="params">...newArg</span>) </span>&#123;</div><div class="line">    arg = arg.concat(newArg);</div><div class="line">    <span class="keyword">return</span> context.apply(obj, arg);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">  F.prototype = context.prototype;</div><div class="line">  bound.prototype = <span class="keyword">new</span> F();</div><div class="line">  <span class="keyword">return</span> bound;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">  <span class="built_in">console</span>.log(a);</div><div class="line">  <span class="built_in">console</span>.log(b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> newFunc = func.bind(&#123; <span class="keyword">new</span>: <span class="literal">true</span> &#125;, <span class="number">1</span>);</div><div class="line">newFunc(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<h2 id="累加输出"><a href="#累加输出" class="headerlink" title="累加输出"></a>累加输出</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getId = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> i++;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(getId()); <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(getId()); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<h2 id="实现一个-add-方法"><a href="#实现一个-add-方法" class="headerlink" title="实现一个 add 方法"></a>实现一个 add 方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) = <span class="number">6</span>;</div><div class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>) = <span class="number">10</span>;</div><div class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>) = <span class="number">15</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...args1</span>) </span>&#123;</div><div class="line">  <span class="comment">// 第一次执行时，定义一个数组专门用来存储所有的参数</span></div><div class="line">  <span class="keyword">var</span> _args = [...args1];</div><div class="line"></div><div class="line">  <span class="comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span></div><div class="line">  <span class="keyword">var</span> _adder = <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</div><div class="line">      _args.push(...args2);</div><div class="line">      <span class="keyword">return</span> _adder;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">// 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span></div><div class="line">  _adder.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> _args.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> a + b;</div><div class="line">      &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> _adder;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)                <span class="comment">// 6</span></div><div class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>)             <span class="comment">// 10</span></div><div class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)          <span class="comment">// 15</span></div><div class="line">add(<span class="number">2</span>, <span class="number">6</span>)(<span class="number">1</span>)                <span class="comment">// 9</span></div></pre></td></tr></table></figure>
<h2 id="B-继承-A"><a href="#B-继承-A" class="headerlink" title="B 继承 A"></a>B 继承 A</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">...</span>) </span>&#123;&#125;</div><div class="line">A.prototype...</div><div class="line">function B(...) &#123;&#125;</div><div class="line">B.prototype...</div><div class="line"></div><div class="line">B.prototype = <span class="built_in">Object</span>.create(A.prototype);</div><div class="line"><span class="comment">// 再在 A 的构造函数里 new B(props);</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'parent'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.age = <span class="number">40</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();</div><div class="line">Child.prototype.constructor = Child;</div><div class="line"></div><div class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Child();</div><div class="line"><span class="built_in">console</span>.log(c.name); <span class="comment">// parent</span></div><div class="line"><span class="built_in">console</span>.log(c.age); <span class="comment">// 40</span></div><div class="line"><span class="built_in">console</span>.log(Child.prototype.constructor); <span class="comment">// Child 函数</span></div></pre></td></tr></table></figure>
<h2 id="对象的深拷贝"><a href="#对象的深拷贝" class="headerlink" title="对象的深拷贝"></a>对象的深拷贝</h2><ul>
<li>一般对象和数组对象的克隆</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> obj) &#123;</div><div class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(item)) &#123;</div><div class="line">      newObj[item] =</div><div class="line">        <span class="keyword">typeof</span> obj[item] == <span class="string">'object'</span> ? deepClone(obj[item]) : obj[item];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> newObj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> copy;</div><div class="line">  <span class="keyword">switch</span> (<span class="keyword">typeof</span> obj) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'undefined'</span>:</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'number'</span>:</div><div class="line">      copy = obj - <span class="number">0</span>;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'string'</span>:</div><div class="line">      copy = obj + <span class="string">''</span>;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'boolean'</span>:</div><div class="line">      copy = obj;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'object'</span>:</div><div class="line">      <span class="keyword">if</span> (obj === <span class="literal">null</span>) &#123;</div><div class="line">        copy = <span class="literal">null</span>;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span>) &#123;</div><div class="line">          copy = [];</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; obj.length; i++) &#123;</div><div class="line">            copy.push(clone(obj[i]));</div><div class="line">          &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          copy = &#123;&#125;;</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> j <span class="keyword">in</span> obj) &#123;</div><div class="line">            copy[j] = clone(obj[j]);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      copy = obj;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> copy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>这个方法不能够拷贝函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</div></pre></td></tr></table></figure>
<h2 id="代码的执行顺序"><a href="#代码的执行顺序" class="headerlink" title="代码的执行顺序"></a>代码的执行顺序</h2><p>参考<a href="https://juejin.cn/post/6844903512845860872" target="_blank" rel="external">这一次，彻底弄懂 JavaScript 执行机制</a></p>
<p>任务队列中，在每一次事件循环中，macrotask 只会提取一个执行，而 microtask 会一直提取，直到 microsoft 队列为空为止。 也就是说如果某个 microtask 任务被推入到执行中，那么当主线程任务执行完成后，会循环调用该队列任务中的下一个任务来执行，直到该任务队列到最后一个任务为止。而事件循环每次只会入栈一个 macrotask，主线程执行完成该任务后又会检查 microtasks 队列并完成里面的所有任务后再执行 macrotask 的任务。<br>macrotasks: setTimeout, setInterval, setImmediate, I/O, UI rendering。<br>microtasks: process.nextTick, Promise, MutationObserver。</p>
<p>同步执行的代码 -&gt; promise.then -&gt; setTimeout</p>
<p>js 引擎单线程执行的，它是基于事件驱动的语言。它的执行顺序是遵循一个叫做事件队列的机制。浏览器有各种各样的线程，比如事件触发器、网络请求、定时器等等，线程的联系都是基于事件的。js 引擎处理到与其他线程相关的代码，就会分发给其他线程。他们处理完之后，需要 js 引擎计算时就是在事件队列里面添加一个任务。这个过程中 js 并不会阻塞代码等待其他线程执行完毕，而且其他线程执行完毕后添加事件任务告诉 js 引擎执行相关操作，这就是 js 的异步编程模型。在指定时间内，将任务放入事件队列，等待 js 引擎空闲后被执行。</p>
<p>那怎么知道主线程执行栈为空啊？js 引擎存在 monitoring process 进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去 Event Queue 那里检查是否有等待被调用的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 输出 2 5 3 6 1 4</span></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"><span class="keyword">var</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">  resolve(<span class="number">3</span>);</div><div class="line">&#125;);</div><div class="line">promise1.then((val) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(val);</div><div class="line">&#125;);</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"><span class="keyword">var</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</div><div class="line">  resolve(<span class="number">6</span>);</div><div class="line">&#125;);</div><div class="line">promise2.then((val) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(val);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不知道是多少，就是从2开始打印的</span></div><div class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  i = <span class="number">0</span>;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;, <span class="number">5000</span>);</div><div class="line"><span class="keyword">while</span> (i) &#123;</div><div class="line">  i++;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 输出 2 1 4 3 5</span></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resole, reject</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">  setTimeout(() =&gt; &#123;</div><div class="line">    resole(<span class="number">3</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</div><div class="line">  &#125;, <span class="number">0</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p.then((a) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(a);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</div><div class="line">&#125;, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//输出 2,6,5,3,4,1</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">  resolve();</div><div class="line">&#125;)</div><div class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</div><div class="line">  &#125;);</div><div class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="number">6</span>);</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 输出 2 10 3 5 4 1</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (i === <span class="number">10</span>) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="number">10</span>);</div><div class="line">    &#125;</div><div class="line">    i == <span class="number">9999</span> &amp;&amp; resolve();</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</div></pre></td></tr></table></figure>
<h2 id="Event-Table"><a href="#Event-Table" class="headerlink" title="Event Table"></a>Event Table</h2><p>就是个注册站，可以理解成一张 事件=&gt;回调函数 对应表，它就是用来存储 JavaScript 中的异步事件 (request, setTimeout, IO 等) 及其对应的回调函数的列表。当指定的事情发生时，Event Table 会将这个函数移到 Event Queue。</p>
<h2 id="实现一个-once-函数，传入函数参数只执行一次"><a href="#实现一个-once-函数，传入函数参数只执行一次" class="headerlink" title="实现一个 once 函数，传入函数参数只执行一次"></a>实现一个 once 函数，传入函数参数只执行一次</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ones</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> tag = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tag == <span class="literal">true</span>) &#123;</div><div class="line">      func.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</div><div class="line">      tag = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="将原生的-ajax-封装成-promise"><a href="#将原生的-ajax-封装成-promise" class="headerlink" title="将原生的 ajax 封装成 promise"></a>将原生的 ajax 封装成 promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myNewAjax = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    xhr.open(<span class="string">'get'</span>, url);</div><div class="line">    xhr.send();</div><div class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</div><div class="line">        <span class="keyword">var</span> json = <span class="built_in">JSON</span>.parse(xhr.responseText);</div><div class="line">        resolve(json);</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status != <span class="number">200</span>) &#123;</div><div class="line">        reject(<span class="string">'error'</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="如何实现一个私有变量，用-getName-方法可以访问，不能直接访问"><a href="#如何实现一个私有变量，用-getName-方法可以访问，不能直接访问" class="headerlink" title="如何实现一个私有变量，用 getName 方法可以访问，不能直接访问"></a>如何实现一个私有变量，用 getName 方法可以访问，不能直接访问</h2><p>如下方式无法解决这个问题，enumerable: false 是 for-in 中不会遍历。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">obj = &#123;</div><div class="line">  name: <span class="string">'abc'</span>,</div><div class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">  &#125;,</div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</div><div class="line">  enumerable: <span class="literal">false</span>,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如下方式可行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">product</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> name = <span class="string">'abc'</span>;</div><div class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> product();</div></pre></td></tr></table></figure>
<h2 id="和-、以及-Object-is-的区别"><a href="#和-、以及-Object-is-的区别" class="headerlink" title="==和===、以及 Object.is 的区别"></a>==和===、以及 Object.is 的区别</h2><ul>
<li>== 等于，存在强制转换成 number，null == undefined 的问题</li>
<li>=== 严格等于，不存在类型转换，存在 NaN !== NaN， +0 === -0</li>
<li>Object.is 加强版严格等于</li>
</ul>
<h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><p>浏览器(所以只能在浏览器中使用)专门为动画提供的 API，让 DOM 动画、Canvas 动画、 SVG 动画、WebGL 动画等有一个统一的刷新机制。requestAnimationFrame 不需要设置时间间隔，RAF 采用的是系统时间间隔，并请求浏览器在下一次重绘之前调用指定的函数来更新动画，一次，若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用 window.requestAnimationFrame()，一般用于动画。</p>
<ul>
<li>requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率</li>
<li>在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量</li>
<li>requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销</li>
</ul>
<h2 id="setTimeout-与-requestAnimationFrame-的区别"><a href="#setTimeout-与-requestAnimationFrame-的区别" class="headerlink" title="setTimeout 与 requestAnimationFrame 的区别"></a>setTimeout 与 requestAnimationFrame 的区别</h2><p>引擎层面：</p>
<ul>
<li>setTimeout 属于 JS 引擎，存在事件轮询，存在事件队列</li>
<li>requestAnimationFrame 属于 GUI 引擎，发生在渲染过程中的重绘重排部分，与电脑分辨路保持一致</li>
</ul>
<p>性能层面：</p>
<ul>
<li>当页面被隐藏或最小化时，定时器 setTimeout 仍在后台执行动画任务</li>
<li>当页面处于未激活的状态下，该页面的屏幕刷新任务会被系统暂停，requestAnimationFrame 也会停止</li>
</ul>
<p>应用层面：</p>
<ul>
<li>利用 setTimeout，这种定时机制去做动画，模拟固定时间刷新页面</li>
<li>requestAnimationFrame 由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，在特定性环境下可以有效节省了 CPU 开销</li>
</ul>
<h2 id="用-setTimeout-来实现-setInterval"><a href="#用-setTimeout-来实现-setInterval" class="headerlink" title="用 setTimeout 来实现 setInterval"></a>用 setTimeout 来实现 setInterval</h2><p>setInterval 有两个问题：1.某些间隔会被跳过 2.多个定时器的代码执行时间 可能会比预期小。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//do something</span></div><div class="line">  setTimeout(say, <span class="number">200</span>);</div><div class="line">&#125;</div><div class="line">setTimeout(say, <span class="number">200</span>);</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// do something</span></div><div class="line">  setTimeout(<span class="built_in">arguments</span>.callee, <span class="number">200</span>);</div><div class="line">&#125;, <span class="number">200</span>);</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_setInterval</span>(<span class="params">fn, time</span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    fn();</div><div class="line">    setTimeout(<span class="built_in">arguments</span>.callee, time);</div><div class="line">  &#125;</div><div class="line">  setTimeout(cb, time);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_setInterval</span>(<span class="params">fn, time</span>) </span>&#123;</div><div class="line">  fn();</div><div class="line">  setTimeout(() =&gt; _setInterval(fn, time), time);</div><div class="line">&#125;</div><div class="line"></div><div class="line">_setInterval(() =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>);</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<h2 id="setTimeout-的时间"><a href="#setTimeout-的时间" class="headerlink" title="setTimeout 的时间"></a>setTimeout 的时间</h2><p>首先要明白 Javascript 是单线程，单线程就意味着所有任务需要排队。然后会将所有任务分成两类：同步任务和异步任务！同步任务：在主线程上执行的任务，只有前一个任务执行完成，才会执行后一个！异步任务：不进入主线程、而进入“任务队列”的任务，当主线程上的任务执行完，主线程才会去执行“任务队列”。</p>
<p>对于 setTimeout(fn,200)，当到 200ms 时，fn 会被放进“任务队列”，而“任务队列”必须要等到主线程已有的代码执行完才会执行 fn，所以当程序执行到 setTimeout(fn,200)这一行时，时间就开始计算，但是 fn 实际执行时并不一定是在 200ms 后，可能是在更久的时间后（取决于主线程上的同步代码的执行时间）。</p>
<h2 id="JS-怎么控制一次加载一张图片，加载完后再加载下一张"><a href="#JS-怎么控制一次加载一张图片，加载完后再加载下一张" class="headerlink" title="JS 怎么控制一次加载一张图片，加载完后再加载下一张"></a>JS 怎么控制一次加载一张图片，加载完后再加载下一张</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> Image();</div><div class="line">  obj.src = <span class="string">'图片地址'</span>;</div><div class="line">  obj.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">'图片的宽度为：'</span> + obj.width + <span class="string">'；图片的高度为：'</span> + obj.height);</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'mypic'</span>).innnerHTML =</div><div class="line">      <span class="string">"&lt;img src='"</span> + <span class="keyword">this</span>.src + <span class="string">"' /&gt;"</span>;</div><div class="line">  &#125;;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mypic"</span>&gt;</span>onloading……<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="如何实现-sleep-的效果（es5-或者-es6）"><a href="#如何实现-sleep-的效果（es5-或者-es6）" class="headerlink" title="如何实现 sleep 的效果（es5 或者 es6）"></a>如何实现 sleep 的效果（es5 或者 es6）</h2><ul>
<li>while 循环的方式，容易造成死循环</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> start = <span class="built_in">Date</span>.now(),</div><div class="line">    expire = start + ms;</div><div class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() &lt; expire);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'1111'</span>);</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过 promise 来实现</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> temple = <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">111</span>);</div><div class="line">    setTimeout(resolve, ms);</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> temple;</div><div class="line">&#125;</div><div class="line">sleep(<span class="number">500</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> temple = <span class="keyword">await</span> sleep(<span class="number">1000</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>);</div><div class="line">  <span class="keyword">return</span> temple;</div><div class="line">&#125;</div><div class="line">test();</div></pre></td></tr></table></figure>
<ul>
<li>通过 generate 来实现</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">111</span>);</div><div class="line">    setTimeout(resolve, ms);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line">sleep(<span class="number">500</span>)</div><div class="line">  .next()</div><div class="line">  .value.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">222</span>);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<h2 id="简单的实现一个-promise"><a href="#简单的实现一个-promise" class="headerlink" title="简单的实现一个 promise"></a>简单的实现一个 promise</h2><p><a href="https://github.com/forthealllight/blog/issues/4" target="_blank" rel="external">实现一个完美符合 Promise/A+规范的 Promise</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">constructor</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</div><div class="line">  self.status = <span class="string">'pending'</span>; <span class="comment">//定义状态改变前的初始状态</span></div><div class="line">  self.value = <span class="literal">undefined</span>; <span class="comment">//定义状态为resolved的时候的状态</span></div><div class="line">  self.reason = <span class="literal">undefined</span>; <span class="comment">//定义状态为rejected的时候的状态</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">//两个==="pending"，保证了状态的改变是不可逆的</span></div><div class="line">    <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</div><div class="line">      self.value = value;</div><div class="line">      self.status = <span class="string">'resolved'</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</div><div class="line">    <span class="comment">//两个==="pending"，保证了状态的改变是不可逆的</span></div><div class="line">    <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</div><div class="line">      self.reason = reason;</div><div class="line">      self.status = <span class="string">'rejected'</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//捕获构造异常</span></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">constructor</span>(resolve, reject);</div><div class="line">  &#125; catch (e) &#123;</div><div class="line">    reject(e);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">myPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFullfilled, onRejected</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">switch</span> (self.status) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'resolved'</span>:</div><div class="line">      onFullfilled(self.value);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'rejected'</span>:</div><div class="line">      onRejected(self.reason);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> mm = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  resolve(<span class="string">'123'</span>);</div><div class="line">&#125;);</div><div class="line">mm.then(</div><div class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">success</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(success);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'fail!'</span>);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseM</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(process) &#123;</div><div class="line">    <span class="keyword">this</span>.status = <span class="string">'pending'</span>;</div><div class="line">    <span class="keyword">this</span>.msg = <span class="string">''</span>;</div><div class="line">    process(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>));</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  resolve(val) &#123;</div><div class="line">    <span class="keyword">this</span>.status = <span class="string">'fulfilled'</span>;</div><div class="line">    <span class="keyword">this</span>.msg = val;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  reject(err) &#123;</div><div class="line">    <span class="keyword">this</span>.status = <span class="string">'rejected'</span>;</div><div class="line">    <span class="keyword">this</span>.msg = err;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  then(fufilled, reject) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'fulfilled'</span>) &#123;</div><div class="line">      fufilled(<span class="keyword">this</span>.msg);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'rejected'</span>) &#123;</div><div class="line">      reject(<span class="keyword">this</span>.msg);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> mm = <span class="keyword">new</span> PromiseM(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  resolve(<span class="string">'123'</span>);</div><div class="line">&#125;);</div><div class="line">mm.then(</div><div class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">success</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(success);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'fail!'</span>);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="Function-proto-getPrototypeOf-是什么？"><a href="#Function-proto-getPrototypeOf-是什么？" class="headerlink" title="Function.proto(getPrototypeOf)是什么？"></a>Function.<em>proto</em>(getPrototypeOf)是什么？</h2><p>获取一个对象的原型，在 chrome 中可以通过 <code>__proto__</code> 的形式，或者在 ES6 中可以通过 <code>Object.getPrototypeOf</code> 的形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></div><div class="line"><span class="built_in">Function</span>.prototype.constructor === <span class="built_in">Function</span>; <span class="comment">// true</span></div><div class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></div><div class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>; <span class="comment">// true</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</div><div class="line">F.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></div><div class="line">F.constructor === <span class="built_in">Function</span>; <span class="comment">// true</span></div><div class="line">f.constructor === F; <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="JS-判断类型"><a href="#JS-判断类型" class="headerlink" title="JS 判断类型"></a>JS 判断类型</h2><p>typeof，instanceof，Object.prototype.toString.call() 等。</p>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><ul>
<li>indexOf 循环去重</li>
<li>ES6 Set 去重 Array.from(new Set(array))</li>
<li>Object 键值对去重，把数组的值存成 Object 的 key 值，比如 Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的</li>
</ul>
<h2 id="JS-实现跨域"><a href="#JS-实现跨域" class="headerlink" title="JS 实现跨域"></a>JS 实现跨域</h2><p>跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript 实施的安全限制，那么只要协议、域名、端口有任何一个不同，都被当作是不同的域。跨域原理，即是通过各种方式，避开浏览器的安全限制。</p>
<ul>
<li>JSONP</li>
<li>document.domain + iframe</li>
<li>window.name + iframe</li>
<li>location.hash + iframe</li>
<li>服务端设置 Access-Control-Allow-Origin</li>
<li>启一个代理服务器进行数据转发</li>
</ul>
<h2 id="JS-数据类型"><a href="#JS-数据类型" class="headerlink" title="JS 数据类型"></a>JS 数据类型</h2><p>引自 MDN <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="external">JavaScript 数据类型和数据结构</a></p>
<p>最新的 ECMAScript 标准定义了 8 种数据类型:</p>
<ul>
<li>6 种原始类型，使用 typeof 运算符检查:<ul>
<li>undefined：typeof instance === “undefined”</li>
<li>Boolean：typeof instance === “boolean”</li>
<li>Number：typeof instance === “number”</li>
<li>String：typeof instance === “string</li>
<li>BigInt：typeof instance === “bigint”</li>
<li>Symbol ：typeof instance === “symbol”</li>
</ul>
</li>
<li>null：typeof instance === “object”。</li>
<li>Object：typeof instance === “object”。任何 constructed 对象实例的特殊非数据结构类型，也用做数据结构：new Object，new Array，new Map，new Set，new WeakMap，new WeakSet，new Date，和几乎所有通过 new keyword 创建的东西。</li>
</ul>
<p>除 Object 以外的所有类型都是不可变的（值本身无法被改变）。</p>
<p>记住 typeof 操作符的唯一目的就是检查数据类型，如果我们希望检查任何从 Object 派生出来的结构类型，使用 typeof 是不起作用的，因为总是会得到 “object”。检查 Object 种类的合适方式是使用 instanceof 关键字。但即使这样也存在误差。</p>
<h2 id="JS-的全排列"><a href="#JS-的全排列" class="headerlink" title="JS 的全排列"></a>JS 的全排列</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fullpermutate</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = [];</div><div class="line">  <span class="keyword">if</span> (str.length &gt; <span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">//遍历每一项</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> m = <span class="number">0</span>; m &lt; str.length; m++) &#123;</div><div class="line">      <span class="comment">//拿到当前的元素</span></div><div class="line">      <span class="keyword">var</span> left = str[m];</div><div class="line">      <span class="comment">//除当前元素的其他元素组合</span></div><div class="line">      <span class="keyword">var</span> rest = str.slice(<span class="number">0</span>, m) + str.slice(m + <span class="number">1</span>, str.length);</div><div class="line">      <span class="comment">//上一次递归返回的全排列</span></div><div class="line">      <span class="keyword">var</span> preResult = fullpermutate(rest);</div><div class="line">      <span class="comment">//组合在一起</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; preResult.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> tmp = left + preResult[i];</div><div class="line">        result.push(tmp);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.length === <span class="number">1</span>) &#123;</div><div class="line">    result.push(str);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="补充-get-和-post-请求在缓存方面的区别"><a href="#补充-get-和-post-请求在缓存方面的区别" class="headerlink" title="补充 get 和 post 请求在缓存方面的区别"></a>补充 get 和 post 请求在缓存方面的区别</h2><ul>
<li>get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存</li>
<li>post 做的一般是修改和删除的工作，所以必须与数据库交互，不能使用缓存</li>
</ul>
<h2 id="说一下闭包"><a href="#说一下闭包" class="headerlink" title="说一下闭包"></a>说一下闭包</h2><p>闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。</p>
<ul>
<li>单例模式</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Singleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> instance;</div><div class="line">  <span class="keyword">var</span> CreateSingleton = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (instance) &#123;</div><div class="line">      <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.getName();</div><div class="line">    instance = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">  &#125;;</div><div class="line">  CreateSingleton.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> CreateSingleton;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Singleton(<span class="string">'a'</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Singleton(<span class="string">'b'</span>);</div><div class="line">a.getName();</div><div class="line">b.getName();</div><div class="line"><span class="built_in">console</span>.log(a === b);</div></pre></td></tr></table></figure>
<h2 id="说说前端中的事件流"><a href="#说说前端中的事件流" class="headerlink" title="说说前端中的事件流"></a>说说前端中的事件流</h2><p>HTML 中与 javascript 交互是通过事件驱动来实现的，例如鼠标点击事件 onclick、页面的滚动事件 onscroll 等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。</p>
<p>什么是事件流：事件流描述的是从页面中接收事件的顺序，DOM2 级事件流包括下面几个阶段：</p>
<ul>
<li>事件捕获阶段</li>
<li>处于目标阶段</li>
<li>事件冒泡阶段</li>
</ul>
<p>addEventListener 是 DOM2 级事件新增的指定事件处理程序的操作，这个方法接收 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。IE 只支持事件冒泡。</p>
<p>DOM0 级和 DOM2 级有什么区别：</p>
<ul>
<li><code>document.getElementById(&quot;btn&quot;).onclick = function(){};</code> 是 DOM0，只能绑定一个事件</li>
<li><code>document.getElementById(&quot;btn&quot;).addEventListener(&quot;click&quot;, function(){}, false);</code> 是 DOM2，可以绑定多个事件</li>
</ul>
<h2 id="如何让事件先冒泡后捕获"><a href="#如何让事件先冒泡后捕获" class="headerlink" title="如何让事件先冒泡后捕获"></a>如何让事件先冒泡后捕获</h2><p>如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。</p>
<h2 id="说一下事件委托或事件代理"><a href="#说一下事件委托或事件代理" class="headerlink" title="说一下事件委托或事件代理"></a>说一下事件委托或事件代理</h2><p>简介：事件委托指的是，不在事件的发生地（直接 dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM 的类型，来做出不同的响应。</p>
<p>举例：最经典的就是 ul 和 li 标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在 li 标签上直接添加，而是在 ul 父元素上添加。 好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</p>
<p>经过试验，在事件捕获阶段做事件代理也可以啊！！！</p>
<h2 id="mouseover-和-mouseenter-的区别"><a href="#mouseover-和-mouseenter-的区别" class="headerlink" title="mouseover 和 mouseenter 的区别"></a>mouseover 和 mouseenter 的区别</h2><p>mouseenter：当鼠标移入元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是 mouseleave</p>
<p>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程，对应的移除事件是 mouseout</p>
<h2 id="异步加载-JS-的方法"><a href="#异步加载-JS-的方法" class="headerlink" title="异步加载 JS 的方法"></a>异步加载 JS 的方法</h2><p>defer：如果 script 标签设置了该属性，会异步的下载并且不会影响到后续 DOM 的渲染，会在文档渲染完毕后 DOMContentLoaded 事件调用前执行；如果有多个设置了 defer 的 script 标签存在，则会按照顺序执行所有的 script。</p>
<p>async：如果 script 标签设置了该属性，会异步的下载并在允许的情况下执行，并不会按着 script 在页面中的顺序来执行，而是谁先加载完谁执行。</p>
<p>一句话，defer 是“渲染完再执行”，async 是“下载完就执行”。另外，如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。</p>
<h2 id="Ajax-解决浏览器缓存问题"><a href="#Ajax-解决浏览器缓存问题" class="headerlink" title="Ajax 解决浏览器缓存问题"></a>Ajax 解决浏览器缓存问题</h2><ul>
<li>在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)</li>
<li>在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)</li>
<li>在 URL 后面加上时间戳：”nowtime=” + new Date().getTime()</li>
<li>如果是使用 jQuery，直接这样就可以了 $.ajaxSetup({cache:false}，这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。</li>
</ul>
<h2 id="垃圾回收的方法"><a href="#垃圾回收的方法" class="headerlink" title="垃圾回收的方法"></a>垃圾回收的方法</h2><p>标记清除和计数引用，用引用计数法会存在内存泄露，如 objA 和 objB 通过各自的属性相互引用。</p>
<h2 id="eval-是做什么的"><a href="#eval-是做什么的" class="headerlink" title="eval 是做什么的"></a>eval 是做什么的</h2><p>将对应的字符串解析成 JS 并执行，应该避免使用，因为非常消耗性能（2 次，一次解析成 JS，一次执行）。</p>
<h2 id="说一下类的创建和继承"><a href="#说一下类的创建和继承" class="headerlink" title="说一下类的创建和继承"></a>说一下类的创建和继承</h2><h2 id="JS-的-new-操作符做了哪些事情"><a href="#JS-的-new-操作符做了哪些事情" class="headerlink" title="JS 的 new 操作符做了哪些事情"></a>JS 的 new 操作符做了哪些事情</h2><p>new 操作符新建了一个空对象，这个对象原型指向构造函数的 prototype，执行构造函数后返回这个对象。</p>
<ul>
<li>创建一个类的实例：创建一个空对象 obj，然后把这个空对象的<strong>proto</strong>设置为构造函数的 prototype</li>
<li>初始化实例：构造函数被传入参数并调用，关键字 this 被设定指向该实例 obj</li>
<li>返回实例 obj</li>
</ul>
<h2 id="JS-的节流和防抖"><a href="#JS-的节流和防抖" class="headerlink" title="JS 的节流和防抖"></a>JS 的节流和防抖</h2><p><a href="http://www.cnblogs.com/coco1s/p/5499469.html" target="_blank" rel="external">http://www.cnblogs.com/coco1s/p/5499469.html</a></p>
<h2 id="暂停死区"><a href="#暂停死区" class="headerlink" title="暂停死区"></a>暂停死区</h2><p>在代码块内，使用 let、const 命令声明变量之前，该变量都是不可用的。这在语法上， 称为“暂时性死区”。</p>
<h2 id="编写代码，满足以下条件：（1）Hero-“37er”-执行结果为-Hi-This-is-37er-（2）Hero-“37er”-kill-1-recover-30-执行结果为-Hi-This-is-37er-Kill-1-bug-Recover-30-bloods-（3）Hero-“37er”-sleep-10-kill-2-执行结果为-Hi-This-is-37er-等待-10s-后-Kill-2-bugs-注意为-bugs-（双斜线后的为提示信息，-不需要打印）"><a href="#编写代码，满足以下条件：（1）Hero-“37er”-执行结果为-Hi-This-is-37er-（2）Hero-“37er”-kill-1-recover-30-执行结果为-Hi-This-is-37er-Kill-1-bug-Recover-30-bloods-（3）Hero-“37er”-sleep-10-kill-2-执行结果为-Hi-This-is-37er-等待-10s-后-Kill-2-bugs-注意为-bugs-（双斜线后的为提示信息，-不需要打印）" class="headerlink" title="编写代码，满足以下条件：（1）Hero(“37er”);执行结果为 Hi! This is 37er （2）Hero(“37er”).kill(1).recover(30);执行结果为 Hi! This is 37er Kill 1 bug Recover 30 bloods （3）Hero(“37er”).sleep(10).kill(2)执行结果为 Hi! This is 37er //等待 10s 后 Kill 2 bugs //注意为 bugs （双斜线后的为提示信息， 不需要打印）"></a>编写代码，满足以下条件：（1）Hero(“37er”);执行结果为 Hi! This is 37er （2）Hero(“37er”).kill(1).recover(30);执行结果为 Hi! This is 37er Kill 1 bug Recover 30 bloods （3）Hero(“37er”).sleep(10).kill(2)执行结果为 Hi! This is 37er //等待 10s 后 Kill 2 bugs //注意为 bugs （双斜线后的为提示信息， 不需要打印）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hero</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">  o.name = name;</div><div class="line">  o.time = <span class="number">0</span>;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi! This is '</span> + o.name);</div><div class="line"></div><div class="line">  o.kill = <span class="function"><span class="keyword">function</span> (<span class="params">bugs</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (bugs == <span class="number">1</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Kill '</span> + bugs + <span class="string">' bug'</span>);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Kill '</span> + bugs + <span class="string">' bugs'</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;, <span class="number">1000</span> * <span class="keyword">this</span>.time);</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  o.recover = <span class="function"><span class="keyword">function</span> (<span class="params">bloods</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Recover '</span> + bloods + <span class="string">' bloods'</span>);</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  o.sleep = <span class="function"><span class="keyword">function</span> (<span class="params">sleepTime</span>) </span>&#123;</div><div class="line">    o.time = sleepTime;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="说一下什么是-virtual-dom"><a href="#说一下什么是-virtual-dom" class="headerlink" title="说一下什么是 virtual dom"></a>说一下什么是 virtual dom</h2><p>用 JavaScript 对象结构表示 DOM 树的结构，然后用这个树构建一个真正的 DOM 树，插到文档当中。当状态变更的时候，重新构造一棵新的对象树，用新的树和旧的树进行比较，记录两棵树差异，把所记录的差异应用到所构建的真正的 DOM 树上，视图就更新了。Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。</p>
<h2 id="简单实现-Node-的-Events-模块，订阅-发布模式"><a href="#简单实现-Node-的-Events-模块，订阅-发布模式" class="headerlink" title="简单实现 Node 的 Events 模块，订阅-发布模式"></a>简单实现 Node 的 Events 模块，订阅-发布模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Events</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.handles = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.on = <span class="function"><span class="keyword">function</span> (<span class="params">eventName, callBack</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.handles[eventName]) &#123;</div><div class="line">      <span class="keyword">this</span>.handles[eventName] = [];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.handles[eventName].push(callBack);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.emit = <span class="function"><span class="keyword">function</span> (<span class="params">eventName, obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handles[eventName]) &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.handles[eventName].length; i++) &#123;</div><div class="line">        <span class="keyword">this</span>.handles[eventName][i](obj);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">eventName, callBack</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!callBack) &#123;</div><div class="line">      <span class="keyword">this</span>.handles[eventName] = [];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.handles[eventName].length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (callBack === <span class="keyword">this</span>.handles[eventName][i]) &#123;</div><div class="line">          <span class="keyword">this</span>.handles[eventName].splice(i, <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> events = <span class="keyword">new</span> Events();</div><div class="line">events.on(<span class="string">'say'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>, name);</div><div class="line">&#125;);</div><div class="line">events.emit(<span class="string">'say'</span>, <span class="string">'Jony yu'</span>);</div></pre></td></tr></table></figure>
<h2 id="写个函数，可以转化下划线命名到驼峰命名"><a href="#写个函数，可以转化下划线命名到驼峰命名" class="headerlink" title="写个函数，可以转化下划线命名到驼峰命名"></a>写个函数，可以转化下划线命名到驼峰命名</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">UnderlineToHump</span>(<span class="params">para</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="string">''</span>;</div><div class="line">  <span class="keyword">var</span> arr = para.split(<span class="string">'_'</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> s <span class="keyword">of</span> arr) &#123;</div><div class="line">    <span class="keyword">if</span> (result.length === <span class="number">0</span>) &#123;</div><div class="line">      result = result + s.toLowerCase();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      result =</div><div class="line">        result + s.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + s.substring(<span class="number">1</span>).toLowerCase();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数组的随机排序"><a href="#数组的随机排序" class="headerlink" title="数组的随机排序"></a>数组的随机排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> i = arr.length;</div><div class="line">  <span class="keyword">while</span> (i) &#123;</div><div class="line">    <span class="keyword">let</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * i);</div><div class="line">    i--;</div><div class="line">    [arr[j], arr[i]] = [arr[i], arr[j]];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="iframe-的优缺点"><a href="#iframe-的优缺点" class="headerlink" title="iframe 的优缺点"></a>iframe 的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>程序调入静态页面比较方便，能够把嵌入的网页原样展现出来</li>
<li>模块分离，便于更改，增加代码的可重用</li>
<li>重载页面时不需要重载整个页面，只需要重载页面中的一个框架页</li>
<li>可以解决跨域问题</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>样式和脚本需要额外链入，增加服务器的 http 请求，占用 http 链接数</li>
<li>会影响搜索引擎优化，不利于网站排名</li>
<li>链接导航需要定义好，否则用户可能无法离开当前框架</li>
<li>阻塞页面加载，影响网页加载速度，window 的 onload 事件需要在所有 iframe 加载完毕后触发</li>
<li>多处滚动条问题</li>
</ul>
<h2 id="vue2-vs-vue3"><a href="#vue2-vs-vue3" class="headerlink" title="vue2 vs. vue3"></a>vue2 vs. vue3</h2><ul>
<li>针对 API 的优化，createApp，生命周期函数修改，组合式 api，如 setup 回调</li>
<li><template> 不再限制一个节点</template></li>
<li>Object.defineProperty 改为 ES6 的 Proxy</li>
<li>加强 TypeScript 支持</li>
<li>更快，重构了虚拟 DOM</li>
<li>更小，Tree-shaking</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/68477600" target="_blank" rel="external">Vue Function-based API RFC</a></p>
<h2 id="React-和-Vue-区别"><a href="#React-和-Vue-区别" class="headerlink" title="React 和 Vue 区别"></a>React 和 Vue 区别</h2><p><a href="https://blog.csdn.net/qq_26190177/article/details/93741368" target="_blank" rel="external">React 和 Vue 区别</a></p>
<ul>
<li>监听数据变化的实现原理不同</li>
</ul>
<p>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，Vue 使用的是可变数据。React 默认是通过比较引用的方式（diff）进行的，React 更强调数据的不可变。</p>
<ul>
<li>数据流的不同</li>
</ul>
<p>Vue 双向绑定。 React 单向数据流。如果使用了 Vuex 以及 Redux 等单向数据流的状态管理框架，可能感受不到这一点的区别了。Vuex 和 Redux 的区别如下。</p>
<p>从表面上来说，store 注入和使用方式有一些区别。在 Vuex 中，$store被直接注入到了组件实例中，因此可以比较灵活的使用：使用dispatch、commit提交更新，通过mapState或者直接通过this.$store 来读取数据。在 Redux 中，我们每一个组件都需要显示的用 connect 把需要的 props 和 dispatch 连接起来。另外，Vuex 更加灵活一些，组件中既可以 dispatch action，也可以 commit updates，而 Redux 中只能进行 dispatch，不能直接调用 reducer 进行修改。</p>
<p>从实现原理上来说，最大的区别是两点：Redux 使用的是不可变数据，而 Vuex 的数据是可变的，因此，Redux 每次都是用新 state 替换旧 state，而 Vuex 是直接修改。Redux 在检测数据变化的时候，是通过 diff 的方式比较差异的，而 Vuex 其实和 Vue 的原理一样，是通过 getter/setter 来比较的，这两点的区别，也是因为 React 和 Vue 的设计理念不同。React 更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue 更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。因此也会给人一种大型项目用 React，小型项目用 Vue 的感觉。</p>
<ul>
<li>组件通信的区别</li>
</ul>
<p>React 本身并不支持自定义事件，Vue 中子组件向父组件传递消息有两种方式：事件和回调函数，而且 Vue 更倾向于使用事件。但是在 React 中我们都是使用回调函数的，这可能是他们二者最大的区别。</p>
<ul>
<li>模板渲染方式的不同</li>
</ul>
<p>React 是通过 JSX 渲染模板，而 Vue 是通过一种拓展的 HTML 语法进行渲染。在深层上，模板的原理不同：React 是在组件 JS 代码中，通过原生 JS 实现模板中的常见语法，比如插值，条件，循环等，都是通过 JS 语法实现的，更加纯粹更加原生。而 Vue 是在和组件 JS 代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要  v-if  来实现对这一点，这样的做法显得有些独特，会把 HTML 弄得很乱。</p>
<p>举个例子，说明 React 的好处：react 中 render 函数是支持闭包特性的，所以我们 import 的组件在 render 中可以直接调用。但是在 Vue 中，由于模板中使用的数据都必须挂在  this  上进行一次中转，所以我们 import  一个组件完了之后，还需要在  components  中再声明下，这样显然是很奇怪但又不得不这样的做法。</p>
<ul>
<li>渲染过程不同</li>
</ul>
<p>Vue 可以更快地计算出 Virtual DOM 的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。React 在应用的状态被改变时，全部子组件都会重新渲染。通过 shouldComponentUpdate 这个生命周期方法可以进行控制，但 Vue 将此视为默认的优化。</p>
<ul>
<li>框架本质不同</li>
</ul>
<p>Vue 本质是 MVVM 框架，由 MVC 发展而来。React 是前端组件化框架，由后端组件化发展而来。</p>
<h2 id="debounce-实现"><a href="#debounce-实现" class="headerlink" title="debounce 实现"></a>debounce 实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDebounced</span>(<span class="params">func, time</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> timer;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span> (timer) &#123;</div><div class="line">      clearTimeout(timer);</div><div class="line">    &#125;</div><div class="line">    timer = setTimeout(() =&gt; &#123;</div><div class="line">      func.apply(that, args);</div><div class="line">    &#125;, time);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="throttle-实现"><a href="#throttle-实现" class="headerlink" title="throttle 实现"></a>throttle 实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThrottle</span>(<span class="params">fn, delay</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> valid = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!valid) &#123;</div><div class="line">      <span class="comment">// 休息时间 暂不接客</span></div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 工作时间，执行函数并且在间隔期内把状态位设为无效</span></div><div class="line">    valid = <span class="literal">false</span>;</div><div class="line">    setTimeout(() =&gt; &#123;</div><div class="line">      fn();</div><div class="line">      valid = <span class="literal">true</span>;</div><div class="line">    &#125;, delay);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="webpack-打包过程"><a href="#webpack-打包过程" class="headerlink" title="webpack 打包过程"></a>webpack 打包过程</h2><p>其中包含四个核心概念</p>
<p>入口(entry)：指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的<br>输出(output)：告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist<br>loader：让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）<br>插件(plugins)：插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。</p>
<ul>
<li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li>
<li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</li>
<li>确定入口：根据配置中的 entry 找出所有的入口文件</li>
<li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li>
<li>完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li>
<li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li>
<li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li>
</ul>
<h2 id="Promise-all-实现"><a href="#Promise-all-实现" class="headerlink" title="Promise.all 实现"></a>Promise.all 实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.prototype.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> results = [];</div><div class="line">  <span class="keyword">let</span> promiseCount = <span class="number">0</span>;</div><div class="line">  <span class="keyword">let</span> promisesLength = promises.length;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promisesLength; i++) &#123;</div><div class="line">      <span class="built_in">Promise</span>.resolve(promises[i]).then(</div><div class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">          promiseCount++;</div><div class="line">          results[i] = res;</div><div class="line">          <span class="keyword">if</span> (promiseCount === promisesLength) &#123;</div><div class="line">            <span class="keyword">return</span> resolve(results);</div><div class="line">          &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> reject(err);</div><div class="line">        &#125;</div><div class="line">      );</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="localStorage-监听"><a href="#localStorage-监听" class="headerlink" title="localStorage 监听"></a>localStorage 监听</h2><p>当同源页面的某个页面修改了 localStorage，其余的同源页面只要注册了 storage 事件，就会触发。</p>
<ul>
<li>同一浏览器打开了两个同源页面</li>
<li>其中一个网页修改了 localStorage</li>
<li>另一网页注册了 storage 事件</li>
</ul>
<p>在同源的两个页面中，可以监听 storage 事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'storage'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  alert(e.newValue);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在同一个页面中，对 localStorage 的 setItem 方法进行重写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> originalSetItem = localStorage.setItem;</div><div class="line"></div><div class="line">localStorage.setItem = <span class="function"><span class="keyword">function</span> (<span class="params">key, newValue</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> setItemEvent = <span class="keyword">new</span> Event(<span class="string">'setItemEvent'</span>);</div><div class="line">  setItemEvent.newValue = newValue;</div><div class="line">  <span class="built_in">window</span>.dispatchEvent(setItemEvent);</div><div class="line">  originalSetItem.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'setItemEvent'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  alert(e.newValue);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">localStorage.setItem(<span class="string">'name'</span>, <span class="string">'wang'</span>);</div></pre></td></tr></table></figure>
<h2 id="router-原理"><a href="#router-原理" class="headerlink" title="router 原理"></a>router 原理</h2><p><a href="https://zhuanlan.zhihu.com/p/27588422" target="_blank" rel="external">【源码拾遗】从 vue-router 看前端路由的两种实现</a></p>
<p>更新视图但不重新请求页面，是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有 2 种方式,Hash 模式和 History 模式。</p>
<p>hash（#）是 URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP 请求中也不会不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置。可以为 hash 的改变添加监听事件：<code>window.addEventListener(&quot;hashchange&quot;, funcRef, false)</code>。</p>
<p>HTML5 History API 提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的 URL，就是利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p>
<h2 id="虚拟-dom-的作用"><a href="#虚拟-dom-的作用" class="headerlink" title="虚拟 dom 的作用"></a>虚拟 dom 的作用</h2><p>之前使用原生 js 或者 jquery 写页面的时候会发现操作 DOM 是一件非常麻烦的一件事情，往往是 DOM 标签和 js 逻辑同时写在 js 文件里，数据交互时不时还要写很多的 input 隐藏域，如果没有好的代码规范的话会显得代码非常冗余混乱，耦合性高并且难以维护。</p>
<p>另外一方面在浏览器里一遍又一遍的渲染 DOM 是非常非常消耗性能的，常常会出现页面卡死的情况；所以尽量减少对 DOM 的操作成为了优化前端性能的必要手段，vdom 就是将 DOM 的对比放在了 js 层，通过对比不同之处来选择新渲染 DOM 节点，从而提高渲染效率。</p>
<p>Virtual DOM 是用 JS 对象记录一个 dom 节点的副本，当 dom 发生更改时候，先用虚拟 dom 进行 diff，算出最小差异，然后再修改真实 dom，当用传统的方式操作 DOM 的时候，浏览器会从构建 DOM 树开始从头到尾执行一遍流程，效率很低。而虚拟 DOM 是用 javascript 对象表示的，而操作 javascript 是很简便高效的。虚拟 DOM 和真正的 DOM 有一层映射关系，很多需要操作 DOM 的地方都会去操作虚拟 DOM，最后统一一次更新 DOM，因而可以提高性能。</p>
<h2 id="找出数组中唯一不同的数"><a href="#找出数组中唯一不同的数" class="headerlink" title="找出数组中唯一不同的数"></a>找出数组中唯一不同的数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findOnly</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</div><div class="line">  arr.forEach((i) =&gt; &#123;</div><div class="line">    result = i ^ result;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果存在2个这样的元素</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findOnlyTwo</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</div><div class="line">  <span class="keyword">let</span> post = <span class="number">0</span>;</div><div class="line">  <span class="keyword">let</span> x = <span class="number">0</span>;</div><div class="line">  <span class="keyword">let</span> y = <span class="number">0</span>;</div><div class="line">  <span class="comment">// 得到所以元素异或结果</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">    result ^= arr[i];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 获取 result 二进制最低位1的位置 1&amp;1 =1</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (((result &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</div><div class="line">      post = i;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 遍历数组得到 x</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">    <span class="keyword">if</span> ((arr[i] &gt;&gt; post) &amp; (<span class="number">1</span> == <span class="number">1</span>)) &#123;</div><div class="line">      x ^= arr[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  y = result ^ x;</div><div class="line">  <span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="找出数组中不相邻元素的最大和"><a href="#找出数组中不相邻元素的最大和" class="headerlink" title="找出数组中不相邻元素的最大和"></a>找出数组中不相邻元素的最大和</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 动态规划</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxSum</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> result = [];</div><div class="line">  result.push(arr[<span class="number">0</span>]);</div><div class="line">  result.push(<span class="built_in">Math</span>.max(arr[<span class="number">0</span>], arr[<span class="number">1</span>]));</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i&lt; arr.length; i++) &#123;</div><div class="line">    <span class="keyword">let</span> a = result[i<span class="number">-2</span>] + arr[i];</div><div class="line">    <span class="keyword">let</span> b = result[i<span class="number">-1</span>];</div><div class="line">    result.push(<span class="built_in">Math</span>.max(a, b));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result[result.length - <span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Vue-大数据量性能优化"><a href="#Vue-大数据量性能优化" class="headerlink" title="Vue 大数据量性能优化"></a>Vue 大数据量性能优化</h2><ul>
<li>减少无用字段</li>
<li>数据扁平化</li>
<li>利用computed</li>
<li>数据静态化</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
      <category term="FJ" scheme="https://zhulichao.github.io/categories/FJ/"/>
    
    
      <category term="FJ" scheme="https://zhulichao.github.io/tags/FJ/"/>
    
  </entry>
  
  <entry>
    <title>多项目跳转</title>
    <link href="https://zhulichao.github.io/2021/06/02/multi-project/"/>
    <id>https://zhulichao.github.io/2021/06/02/multi-project/</id>
    <published>2021-06-02T01:11:05.000Z</published>
    <updated>2021-08-11T08:16:24.317Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>打包后 vue-router 多次引用</li>
<li>跳转是用 a 标签，路由可能跳不过去</li>
</ul>
<p>注意：引用静态资源的路径可能需要处理</p>
<h2 id="基于-qiankun"><a href="#基于-qiankun" class="headerlink" title="基于 qiankun"></a>基于 qiankun</h2><ul>
<li>babel-polyfill 多次引用 idempotent-babel-polyfill</li>
</ul>
<h3 id="主应用修改"><a href="#主应用修改" class="headerlink" title="主应用修改"></a>主应用修改</h3><ul>
<li>npm install qiankun</li>
<li>router 删除 notFoundRouter 的重定向</li>
<li>修改 main.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; registerMicroApps, start &#125; <span class="keyword">from</span> <span class="string">'qiankun'</span></div><div class="line"><span class="comment">// import BabelPolyfill from 'babel-polyfill'</span></div><div class="line"><span class="comment">// Vue.use(BabelPolyfill)</span></div><div class="line"></div><div class="line"><span class="comment">// 添加</span></div><div class="line">registerMicroApps(</div><div class="line">  [</div><div class="line">    &#123;</div><div class="line">      name: <span class="string">'project'</span>,</div><div class="line">      entry: <span class="string">'//localhost:8002'</span>,</div><div class="line">      container: <span class="string">'#app'</span>,</div><div class="line">      activeRule: <span class="string">'/cms'</span></div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">)</div><div class="line"></div><div class="line">start()</div></pre></td></tr></table></figure>
<h3 id="跳转应用修改"><a href="#跳转应用修改" class="headerlink" title="跳转应用修改"></a>跳转应用修改</h3><ul>
<li>修改 webpack 配置</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">output: &#123;</div><div class="line">  <span class="comment">// 把子应用打包成 umd 库格式(必须)</span></div><div class="line">  library: <span class="string">`<span class="subst">$&#123;packageName&#125;</span>-[name]`</span>,</div><div class="line">  libraryTarget: <span class="string">'umd'</span>,</div><div class="line">  jsonpFunction: <span class="string">`webpackJsonp_<span class="subst">$&#123;packageName&#125;</span>`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">devServer: &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  headers: &#123;</div><div class="line">    <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'*'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>router 设置 base</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</div><div class="line">  mode: <span class="string">'history'</span>,</div><div class="line">  base: <span class="built_in">window</span>.__POWERED_BY_QIANKUN__ ? <span class="string">'/cms'</span> : <span class="string">'/'</span>,</div><div class="line">  routes: constantRouterMap</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>修改 main.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 修改</span></div><div class="line"><span class="keyword">import</span> bootstrap2 <span class="keyword">from</span> <span class="string">'./core/bootstrap'</span></div><div class="line"></div><div class="line"><span class="comment">// 删除</span></div><div class="line"><span class="comment">// new Vue(&#123;</span></div><div class="line"><span class="comment">//   router,</span></div><div class="line"><span class="comment">//   store,</span></div><div class="line"><span class="comment">//   i18n,</span></div><div class="line"><span class="comment">//   created: bootstrap,</span></div><div class="line"><span class="comment">//   render: h =&gt; h(App)</span></div><div class="line"><span class="comment">// &#125;).$mount('#app')</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> instance = <span class="literal">null</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">props = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123; container &#125; = props</div><div class="line"></div><div class="line">  instance = <span class="keyword">new</span> Vue(&#123;</div><div class="line">    router,</div><div class="line">    store: store,</div><div class="line">    i18n,</div><div class="line">    created: bootstrap2,</div><div class="line">    render: h =&gt; h(App)</div><div class="line">  &#125;).$mount(container ? container.querySelector(<span class="string">'#app'</span>) : <span class="string">'#app'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__POWERED_BY_QIANKUN__) &#123;</div><div class="line">  <span class="comment">// eslint-disable-next-line</span></div><div class="line">  __webpack_public_path__ = <span class="built_in">window</span>.__INJECTED_PUBLIC_PATH_BY_QIANKUN__</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// 独立运行</span></div><div class="line">  render()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。</div><div class="line"> * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'app bootstraped'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span> (<span class="params">props</span>) </span>&#123;</div><div class="line">  render(props)</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span> (<span class="params">props</span>) </span>&#123;</div><div class="line">  instance.$destroy()</div><div class="line">  instance.$el.innerHTML = <span class="string">''</span></div><div class="line">  instance = <span class="literal">null</span></div><div class="line">  router = <span class="literal">null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>线上 nginx</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">location /api/ &#123;</div><div class="line">  add_header Access-Control-Allow-Origin *;</div><div class="line">  add_header Access-Control-Allow-Methods <span class="string">'GET, POST, OPTIONS'</span>;</div><div class="line">  add_header Access-Control-Allow-Headers <span class="string">'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,refresh_token'</span>;</div><div class="line">  <span class="keyword">if</span> (<span class="variable">$request_method</span> = <span class="string">'OPTIONS'</span>) &#123;</div><div class="line">      <span class="built_in">return</span> 204;</div><div class="line">  &#125;</div><div class="line">  proxy_pass http://192.168.103.219:30005/;</div><div class="line">&#125;</div><div class="line"></div><div class="line">location / &#123;</div><div class="line">  add_header Access-Control-Allow-Origin *;</div><div class="line">  add_header Access-Control-Allow-Methods <span class="string">'GET, POST, OPTIONS'</span>;</div><div class="line">  add_header Access-Control-Allow-Headers <span class="string">'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'</span>;</div><div class="line">  root /usr/<span class="built_in">local</span>/Cellar/nginx/1.19.5/pcm/dist12;</div><div class="line">  try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ @router;</div><div class="line">  index index.html index.htm;</div><div class="line">  add_header Cache-Control max-age=no-cache;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="基于-nginx-转发"><a href="#基于-nginx-转发" class="headerlink" title="基于 nginx 转发"></a>基于 nginx 转发</h2><ul>
<li>主应用没有修改</li>
<li>跳转的应用<ul>
<li>设置 publicPath 为 ‘/cms’</li>
<li>router 设置 base 为 ‘/cms’</li>
</ul>
</li>
</ul>
<h3 id="一个前端项目"><a href="#一个前端项目" class="headerlink" title="一个前端项目"></a>一个前端项目</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">location /cms/api/ &#123;</div><div class="line">    add_header Access-Control-Allow-Origin *;</div><div class="line">    add_header Access-Control-Allow-Methods <span class="string">'GET, POST, OPTIONS'</span>;</div><div class="line">    add_header Access-Control-Allow-Headers <span class="string">'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,refresh_token'</span>;</div><div class="line">    <span class="keyword">if</span> (<span class="variable">$request_method</span> = <span class="string">'OPTIONS'</span>) &#123;</div><div class="line">        <span class="built_in">return</span> 204;</div><div class="line">    &#125;</div><div class="line">    proxy_pass http://192.168.103.219:30005/;</div><div class="line">&#125;</div><div class="line"></div><div class="line">location /api/ &#123;</div><div class="line">    add_header Access-Control-Allow-Origin *;</div><div class="line">    add_header Access-Control-Allow-Methods <span class="string">'GET, POST, OPTIONS'</span>;</div><div class="line">    add_header Access-Control-Allow-Headers <span class="string">'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,refresh_token'</span>;</div><div class="line">    <span class="keyword">if</span> (<span class="variable">$request_method</span> = <span class="string">'OPTIONS'</span>) &#123;</div><div class="line">        <span class="built_in">return</span> 204;</div><div class="line">    &#125;</div><div class="line">    proxy_pass http://192.168.103.219:30005/;</div><div class="line">&#125;</div><div class="line"></div><div class="line">location /cms &#123;</div><div class="line">    <span class="built_in">alias</span> /usr/<span class="built_in">local</span>/Cellar/nginx/1.19.5/pcm/dist2/;</div><div class="line">    try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ ../dist2/index.html <span class="built_in">break</span>; <span class="comment"># 注意这个 break</span></div><div class="line">    index index.html index.htm;</div><div class="line">&#125;</div><div class="line"></div><div class="line">location / &#123;</div><div class="line">    root /usr/<span class="built_in">local</span>/Cellar/nginx/1.19.5/pcm/dist1;</div><div class="line">    index index.html index.htm;</div><div class="line">    try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多个前端项目"><a href="#多个前端项目" class="headerlink" title="多个前端项目"></a>多个前端项目</h3><p>主项目配置如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">location /api/ &#123;</div><div class="line">    add_header Access-Control-Allow-Origin *;</div><div class="line">    add_header Access-Control-Allow-Methods <span class="string">'GET, POST, OPTIONS'</span>;</div><div class="line">    add_header Access-Control-Allow-Headers <span class="string">'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,refresh_token'</span>;</div><div class="line">    <span class="keyword">if</span> (<span class="variable">$request_method</span> = <span class="string">'OPTIONS'</span>) &#123;</div><div class="line">        <span class="built_in">return</span> 204;</div><div class="line">    &#125;</div><div class="line">    proxy_pass http://192.168.103.219:30005/;</div><div class="line">&#125;</div><div class="line"></div><div class="line">location /cms &#123;</div><div class="line">    add_header Access-Control-Allow-Origin *;</div><div class="line">    add_header Access-Control-Allow-Methods <span class="string">'GET, POST, OPTIONS'</span>;</div><div class="line">    add_header Access-Control-Allow-Headers <span class="string">'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'</span>;</div><div class="line">    <span class="keyword">if</span> (<span class="variable">$request_method</span> = <span class="string">'OPTIONS'</span>) &#123;</div><div class="line">        <span class="built_in">return</span> 204;</div><div class="line">    &#125;</div><div class="line">    proxy_pass http://localhost:1889;</div><div class="line">&#125;</div><div class="line"></div><div class="line">location / &#123;</div><div class="line">    root /usr/<span class="built_in">local</span>/Cellar/nginx/1.19.5/pcm/dist1;</div><div class="line">    try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ @router;</div><div class="line">    index index.html index.htm;</div><div class="line">    add_header Cache-Control max-age=no-cache;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>跳转项目配置如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">location /cms/api/ &#123;</div><div class="line">    add_header Access-Control-Allow-Origin *;</div><div class="line">    add_header Access-Control-Allow-Methods <span class="string">'GET, POST, OPTIONS'</span>;</div><div class="line">    add_header Access-Control-Allow-Headers <span class="string">'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,refresh_token'</span>;</div><div class="line">    <span class="keyword">if</span> (<span class="variable">$request_method</span> = <span class="string">'OPTIONS'</span>) &#123;</div><div class="line">        <span class="built_in">return</span> 204;</div><div class="line">    &#125;</div><div class="line">    proxy_pass http://192.168.103.219:30005/;</div><div class="line">&#125;</div><div class="line"></div><div class="line">location /api/ &#123;</div><div class="line">    add_header Access-Control-Allow-Origin *;</div><div class="line">    add_header Access-Control-Allow-Methods <span class="string">'GET, POST, OPTIONS'</span>;</div><div class="line">    add_header Access-Control-Allow-Headers <span class="string">'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,refresh_token'</span>;</div><div class="line">    <span class="keyword">if</span> (<span class="variable">$request_method</span> = <span class="string">'OPTIONS'</span>) &#123;</div><div class="line">        <span class="built_in">return</span> 204;</div><div class="line">    &#125;</div><div class="line">    proxy_pass http://192.168.103.219:30005/;</div><div class="line">&#125;</div><div class="line"></div><div class="line">location /cms &#123;</div><div class="line">    <span class="built_in">alias</span> /usr/<span class="built_in">local</span>/Cellar/nginx/1.19.5/pcm/dist2/;</div><div class="line">    try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/;</div><div class="line">    index index.html index.htm;</div><div class="line">&#125;</div><div class="line"></div><div class="line">location / &#123;</div><div class="line">    root /usr/<span class="built_in">local</span>/Cellar/nginx/1.19.5/pcm/dist2;</div><div class="line">    try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</div><div class="line">    index index.html index.htm;</div><div class="line">    add_header Cache-Control max-age=no-cache;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
      <category term="Project Base" scheme="https://zhulichao.github.io/categories/Project-Base/"/>
    
    
      <category term="Project Base" scheme="https://zhulichao.github.io/tags/Project-Base/"/>
    
  </entry>
  
  <entry>
    <title>Vue 生命周期钩子</title>
    <link href="https://zhulichao.github.io/2021/04/16/vue-lifecycle/"/>
    <id>https://zhulichao.github.io/2021/04/16/vue-lifecycle/</id>
    <published>2021-04-16T07:07:27.000Z</published>
    <updated>2021-08-11T08:16:24.315Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>参考</p>
<ul>
<li><p>官方文档 <a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" target="_blank" rel="external">生命周期钩子</a>。</p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_42707287/article/details/111641286" target="_blank" rel="external">超详细vue生命周期解析(详解)</a></p>
</li>
</ul>
<h2 id="Vue-生命周期钩子"><a href="#Vue-生命周期钩子" class="headerlink" title="Vue 生命周期钩子"></a>Vue 生命周期钩子</h2><ul>
<li>beforeCreate<ul>
<li>实例初始化后、创建之前调用</li>
<li>没有实例化，不能访问数据</li>
</ul>
</li>
<li>created<ul>
<li>实例创建后调用</li>
<li>能访问到数据，能修改数据且不会触发 update 阶段</li>
<li>异步数据的获取和对实例数据的初始化操作都在这里面进行</li>
</ul>
</li>
<li>beforeMount<ul>
<li>编译模板已经结束，虚拟 DOM 已经存在，真实的 DOM 节点挂载到页面之前调用</li>
<li>能访问到数据，能修改数据且不会触发 update 阶段</li>
</ul>
</li>
<li>mounted<ul>
<li>真实的 DOM 节点挂载到页面之后调用，可以使用 $el、$refs 拿到节点</li>
<li>能访问到数据，能修改数据但会触发 update 阶段</li>
</ul>
</li>
<li>activated<ul>
<li>被 keep-alive 缓存的组件激活时（包括第一次）调用</li>
</ul>
</li>
<li>deactivated<ul>
<li>被 keep-alive 缓存的组件停用时调用</li>
</ul>
</li>
<li>beforeUpdate<ul>
<li>数据更新时调用，发生在虚拟 DOM 打补丁之前</li>
<li>能访问到数据，能修改数据不会再次触发 update 阶段</li>
<li>这里适合在更新之前访问现有的 DOM</li>
</ul>
</li>
<li>updated<ul>
<li>组件 DOM 更新之后调用</li>
<li>能访问到数据，包括 beforeUpdate 修改后的数据，能修改数据会再次触发 update 阶段</li>
<li>应该避免在此期间更改状态，可能会引起死循环</li>
</ul>
</li>
<li>beforeDestroy<ul>
<li>实例销毁之前调用，此时实例仍然完全可用</li>
<li>能访问到数据，能修改数据不会再触发 update 阶段</li>
<li>能访问到 $el</li>
<li>可以清理非vue资源，防止内存泄露</li>
</ul>
</li>
<li>destroyed<ul>
<li>实例销毁之后调用，所有子实例也都销毁了，清除vue实例与DOM的关联</li>
<li>能访问到数据，能修改数据不会再触发 update 阶段</li>
<li>能访问到 $el</li>
</ul>
</li>
<li>errorCaptured<ul>
<li>当捕获一个来自子孙组件的错误时被调用</li>
</ul>
</li>
</ul>
<img src="/2021/04/16/vue-lifecycle/lifecycle1.png" title="生命周期执行顺序">
<img src="/2021/04/16/vue-lifecycle/lifecycle2.png" title="生命周期执行顺序">
<p><strong>注意：</strong></p>
<ul>
<li><p>只有在 template 中引用的变量变化时，视图才会更新，否则无论 data 还是 props 变化，都不会触发更新</p>
</li>
<li><p>若只有父组件的 data 变化，只更新父组件，子组件不更新</p>
</li>
<li><p>执行了销毁，是清除 Vue 实例与 DOM 的关联，页面中 DOM 元素可能仍然存在，Vue Devtools 中没有对应节点了</p>
</li>
<li><p>如果有 watch 先进入 watch，再进入 beforeUpdate</p>
</li>
<li><p>如果 watch 中又对监听的属性进行了修改，会再次进入 watch，然后再进入 beforeUpdate</p>
</li>
</ul>
<img src="/2021/04/16/vue-lifecycle/lifecycle3.png" title="生命周期执行顺序">
<h2 id="为什么不能用箭头函数"><a href="#为什么不能用箭头函数" class="headerlink" title="为什么不能用箭头函数"></a>为什么不能用箭头函数</h2><p>函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</p>
<p>箭头函数没有自己的 this，它的 this 是继承而来；默认指向在定义它时所处的对象(宿主对象)，而不是执行时的对象，定义它的时候，可能环境是 window；箭头函数可以方便地让我们在 setTimeout 、setInterval中方便的使用 this。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj1 = &#123;</div><div class="line">  name: <span class="string">'ces'</span>,</div><div class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj1.method(); <span class="comment">// obj1</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> obj2 = &#123;</div><div class="line">  name: <span class="string">'ces'</span>,</div><div class="line">  method: () =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj2.method(); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>类内部自身调用时 this 就是自己的实例，但是如果传给其它地方调用了，this 就变了，所以有了 bind this、箭头函数这种写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString1() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString2 = () =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> point = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">point.toString1(); <span class="comment">// (1, 2)</span></div><div class="line">point.toString2(); <span class="comment">// (1, 2)</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  x: <span class="number">3</span>,</div><div class="line">  y: <span class="number">4</span>,</div><div class="line">  toString1: point.toString1,</div><div class="line">  toString2: point.toString2,</div><div class="line">&#125;;</div><div class="line">obj.toString1(); <span class="comment">// (3, 4)</span></div><div class="line">obj.toString2(); <span class="comment">// (1, 2)</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
      <category term="Vue" scheme="https://zhulichao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://zhulichao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>IE11 兼容调试</title>
    <link href="https://zhulichao.github.io/2021/04/13/ie11-compatibility/"/>
    <id>https://zhulichao.github.io/2021/04/13/ie11-compatibility/</id>
    <published>2021-04-13T08:00:01.000Z</published>
    <updated>2021-08-11T08:16:24.315Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h2><ul>
<li>最困难的是看不见报错信息，开发者工具打开就崩溃</li>
<li>简化项目，删除一些文件，注释一些路由，如注释了 cesium、three、example 的路由，看到报错信息了，添加了 babel-polyfill</li>
<li>放开 example 路由，看示例程序就崩溃，把示例 html 中的内容粘贴到 index.html 中运行，看到了报错，html 中集成 babel 转码和 polyfill 兼容 IE11</li>
<li>修改了 babel-loader 处理的范围，添加了 cesium、three 包</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>DOM 操作的 append 方法改为 appendChild 方法</li>
<li>示例程序的 html 中尽量不写 ES6 语法</li>
<li>示例程序的 html 中不要写 async await，使用 then 回调</li>
<li>示例程序的 html 中变量要有声明</li>
<li>WebGL 是实验性的，可能会有问题</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
      <category term="前端知识" scheme="https://zhulichao.github.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="前端知识" scheme="https://zhulichao.github.io/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>《精益创业UX篇 高效用户体验设计》笔记</title>
    <link href="https://zhulichao.github.io/2021/04/04/lean-ux/"/>
    <id>https://zhulichao.github.io/2021/04/04/lean-ux/</id>
    <published>2021-04-03T17:50:35.000Z</published>
    <updated>2021-08-11T08:16:24.315Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>在开发产品之前，弄清楚用户是否会购买你的产品。</li>
<li>在整个产品生命周期中，倾听用户的心声。</li>
<li>理解为何在设计一款产品之前要做测试。</li>
<li>获得对产品设计至关重要的9个工具。</li>
<li>区分必须的功能和有则更好的功能。</li>
<li>学习最小化可行产品是如何影响用户体验设计决策的。</li>
<li>协同使用A/B测试与优秀的用户体验设计实践。</li>
<li>加速产品开发过程而不牺牲产品质量。</li>
</ul>
<p>全书共3篇，分别从验证、设计及产品3个方面介绍了精益用户体验设计。</p>
<p>你应该了解如何设计简单产品，A/B测试，然后周期迭代改进。对了，别忘了还有持续部署、敏捷开发和最小化可行产品。</p>
<p>和精益创业非常相似，精益用户体验设计时围绕着验证假设展开的。</p>
<p>精益用户体验设计认为产品是由一组有待验证的假设所组成的。换句话说，不要以为我们知道用户想要什么。我们做用户访谈和用户调研就是为了拟定关于用户可能需要什么的假设，然后以各种方式验证这一假设，来看看我们是否正确。每一次验证都帮助我们对产品进行改进。</p>
<p>精益用户体验设计不是简单地把功能添加到产品，它是要找出关于驱动业务的指标，了解我们可以解决的客户问题从而推动指标的增长，产生改善这些客户问题的想法，然后验证这些想法是否正确。</p>
<p>很多精益创业公司都会落入这个陷阱：无法判断一个假设是否被验证了。</p>
<p>精益用户体验设计是以用户为中心的（User Centered Design，UCD）。</p>
<p>精益用户体验设计是敏捷的。</p>
<p>精益用户体验设计是由数据驱动的。</p>
<p>精益用户体验设计是快速和低成本的（某些时候）。</p>
<p>精益用户体验设计是迭代改进的（一直都是）。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>思考产品点子的时候，人们会犯一个很常见的错，要么是这个产品要解决的问题根本不存在，要么是痛点还不够痛，没有达到人们忍无可忍，想要解决它的程度。</p>
<p>但如果找不到需要解决的问题，那么人们也就没有足够充分的理由购买你的产品。就算你的点子再怎么棒、有创意、具有颠覆性的，早期验证可以让你更好地理解用户和完善你的点子。</p>
<p>创业是在充满各种高度不确定性的情况下进行产品或服务创新，尽早验证问题足以降低这种不确定性。</p>
<p>验证市场的第一个目标是缩小受众人群——那些希望问题能够被彻底解决的人们。第二个目标是去了解他们为什么对你的方案感兴趣，由此你还可以找到相似的市场，他们也有类似的动机。</p>
<p>当你能精确地预测某类人将会遇到的某个特殊问题，并且这个问题也足够严重，以至于他们愿意花钱购买解决方案，那么此时，就算你已经成功验证了你的市场了。</p>
<p>用于早期验证的方法：</p>
<ul>
<li><p>用户行为习惯研究（倾听你的用户）</p>
<p>在做用户行为研究的时候，非常容易犯一个错误，那就是告诉受访者你正在制作什么样的产品，以及这个产品是多么适合他们。如果给用户灌输你的想法的话，没有什么能比这更快地把用户带到沟里去。</p>
</li>
<li><p>着陆页测试</p>
<p>在制作产品之前先售卖产品。通过制作一个只有一些简单页面的网站，你可以得到一些粗略的数据，它能够揭示出有多少人对你的解决方案感兴趣。这样做有个好处，那就是你可以在制作产品之前就开始制作这样的网站。</p>
</li>
<li><p>原型测试</p>
<p>正确的方式是，给用户展示一些东西，并且观察他们的反应。最理想的情况是，你给用户展示的东西最好看上去，或者让他们感觉到这确实是一个产品，但是又并不需要你花上几个月的时间来写代码来制作这个东西。原型测试是个永不尽早验证你的产品的最佳方式。</p>
</li>
</ul>
<p>痛点驱动设计（Pain-Driven Design，PDD）要求你在开始设计产品或者新功能之前，首先要弄明白是什么东西让你的用户或者潜在用户感到难受。</p>
<p>如果你在对的时间做对的研究，你最终会节省时间和金钱。我已经提到过你应该做的几种不同类型的用户研究：用户验证和原型测试。</p>
<p>去测试别人的产品，你要做的不是去帮他们修复问题，而是要避免他们犯过的所有错误。</p>
<ul>
<li>你喜欢这个产品的什么地方？</li>
<li>你不喜欢这个产品的什么地方？</li>
<li>你对这个产品的哪里感到困惑？</li>
<li>这个产品有什么让你感到特别不爽吗？</li>
<li>这个产品缺少什么吗？</li>
<li>你如何学会使用这个产品？</li>
<li>你是在哪里听说这个产品的？</li>
<li>你试用过其他类似的产品吗？</li>
<li>为什么你选了这个产品而不是其他的呢？</li>
<li>（用于企业产品）哪部分工作是你必须要做、但这个产品却没有提供相应功能的？你是如何看待这个问题的？</li>
</ul>
<p>在你打算创业时最重要的决策之一就是如何对用户描述产品。</p>
<p>A/B测试可以告诉你在各个着陆页中哪一个效果最好。</p>
<p>找出用户对你的着陆页反应的唯一方法是问答下面的问题：</p>
<ul>
<li>用户觉得这个产品是做什么的？</li>
<li>用户认为这个产品是给谁用的？</li>
<li>用户知道如何获取该产品吗？</li>
</ul>
<p>UsabilityHub是一个远程用户测试平台，通过5秒钟测试、单击测试、导航测试、问题测试和偏好测试等，你可获得真实快捷的用户反馈。UsabilityHub作为研究用户数据的工具可帮助开发，设计以及营销人员改善目标网页和应用程序的用户体验，从而提升你网站的转化率。</p>
<p>为了在任何类型的用户调研中都发挥到极致，在发现共性问题之前，最好找尽量少的人进行测试。然后你会一次次地测试这些人，同时也会在每次测试之间留下足够多的时间来修改产品、样品、原型、讨论方案，或者任何你打算进行测试的东西。</p>
<p>只有一种类型的调研需要亲自面对面进行，那就是你需要了解用户在什么环境中使用你的产品，或者用户和产品在一起的时候才能进行测试。</p>
<p>非监管测试是指，你可以自动获得一个关于真实用户使用你的产品的视频，视频中的人尝试着去执行各种你所指派的任务。它最不适合用来做什么：</p>
<ul>
<li>了解人们是否喜欢你的产品</li>
<li>了解人们是否会使用你的产品</li>
<li>了解人们在他们的设备上并且在没有任何提示的情况下使用你的产品的时候，是否还能知道他们应该执行什么任务</li>
<li>了解真实用户每天都是怎么使用你的产品的</li>
<li>了解如何修复你发现的易用性问题</li>
<li>其他</li>
</ul>
<p>定性研究，这主要包括和用户会谈，观察并理解他们的行为。这里跟统计学无关。这里有几个定性研究的例子：</p>
<ul>
<li>情境问答</li>
<li>易用性研究</li>
<li>客服访谈</li>
</ul>
<p>定量研究指的是测量真实用户是如何使用你的产品的。它不涉及和某一个人交谈，而更多的是关于研究聚合的数据。这是具有统计学意义的。这里有几个定量研究的例子：</p>
<ul>
<li>漏斗分析</li>
<li>A/B测试</li>
<li>群组分析</li>
</ul>
<p>定量研究会告诉你问题是什么，定性研究会告诉你为什么有这样的问题。</p>
<p>定性的方法：</p>
<ul>
<li>定期观察用户使用你的产品</li>
<li>和那些放弃使用你的产品的人交流</li>
<li>观察新用户使用你的产品，问问他们在开始使用产品的最初15分钟里，他们期望的是什么</li>
</ul>
<p>定量的方法：</p>
<ul>
<li>观察那些被最有价值的用户使用得最多的产品功能</li>
<li>尝试使用“假功能“测试，这可以通过添加一个按钮或者导航元素</li>
</ul>
<p>最佳的策略是，确保你总是能够追踪到你的指标，并且观察人们使用你的产品。</p>
<p>定性研究能够很明确地告诉你，用户能否做某件事。它可以告诉你这个功能对于用户而言是否有意义，以及用户能否成功完成某项任务。</p>
<p>定性研究对于判断用户是否愿意做某些事情也是有一定效果的，因为用户很有可能会做这些事情，只要产品或者功能不要太难以使用。</p>
<p>当你在决定到底是选择定性研究还是定量研究的时候，有件很重要事情得记住，那就是问自己，到底是想要知道发生了什么，还是想知道为什么某件事会发生。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>设计就是关于解决问题的。一旦你很好地定义你的问题，并确定你想要的产品结果是什么，为了防止万一你的最终产物存在缺陷，精益用户体验设计鼓励你用尽量少的工作量尽快的制作出你期望的结果。这意味着要先做设计并去验证你的假设。</p>
<p>在精益用户体验设计中，你应该尽可能多地区验证你的假设。</p>
<ul>
<li>工具1：真正了解问题</li>
<li>工具2：先设计测试</li>
<li>工具3：写一些故事</li>
<li>工具4：与团队讨论可能的解决方案</li>
<li>工具5：做出决策</li>
<li>工具6：验证方法是否有效</li>
<li>工具7：一些草绘的方法，Balsamiq 或 OmniGraffle 草绘工具</li>
<li>工具8：创建交互原型</li>
<li>工具9：测试和迭代改进</li>
</ul>
<p>如果要我说出精益用户体验设计区别于其他设计方式的最明显的一点的话，那答案就是测试。</p>
<p>还要补充一点：给用户真正想要的。一个客户说：”我想要某个功能“，企业家和产品负责人往往写下”客户想要某个功能“，而不是了解他为什么想要这个功能，然后就开始制作这个功能了。</p>
<p>卓越设计当中很重要的一环就是把时间花在重要的事情上，而不要浪费在那些无关紧要的事情上。</p>
<ul>
<li>这个问题影响到谁了？</li>
<li>影响到他们的频率有多高？</li>
<li>这个问题对哪一个关键指标造成了破坏？</li>
</ul>
<p>流程图适合用来做什么？当你想要弄清楚用户在产品中的移动路径，以及他们是如何完成某些常规任务的时候，最好是用流程图或者站点地图。它对预估工作量也有极大帮助，还可以辅助你和开发人员就设计问题进行沟通交流。</p>
<p>流程图不合适拿来验证假设，或者用于易用性测试，因为它不是设计给用户看到。</p>
<p>草绘图是你首次开始试着把产品或者功能变得可视化。别再从”用户需要登录“这个角度思考问题，而应该多思考用户在登录过程中可能需要哪些元素，以及这些元素之间的关系。</p>
<p>在你思考问题的时候，应该采用草绘图，因为它非常便捷，灵活度高。你可以毫不费力的在页面上画各种各样的元素，移动调整它们的位置，甚至删除或者再加入一些元素。你也可以制作一堆草绘图，每一个都包含众多的元素，或者把不同的信息归类放置。总之，你可以很容易地做各种试验。</p>
<p>草绘图还可以帮你和其他人沟通交流你的设计思路。</p>
<p>草绘图并不能用来从用户那里收集反馈信息。</p>
<p>在我看来，一个使用的线框图必须包含所有的真实产品中的文字、按钮、关键操作，以及导航元素。而且此时它还没有任何视觉设计，这将在后面的环节中添加进来。但是可以肯定的是，线框图包含了所有在制作草绘图的时候设计出来的元素，并且不仅仅只是把这些元素组合到一起，还要让它们支撑起整个功能或者产品。</p>
<p>重要的是要记住，线框图是用来让你弄清楚屏幕上或者产品的某个工作状态下的每一处细节的。</p>
<p>制作交互式原型产品的最佳理由是，在花费大量时间和金钱制作真正的产品之前，它有助于帮你找出设计里的错误。基本上来讲，当原型产品可以帮你节省时间和金钱的时候，你就应该使用它。</p>
<p>关于交互式原型很重要的一件事情就是，当制作一个要耗费很多时间才能上线的功能的时候，或者后续的修补成本很高的时候，它很适合用来测试你的产品。</p>
<p>在设计的最初阶段，还在和团队成员头脑风暴各种不同的点子的时候，纸上原型可以让每个人都对产品有统一的认识。这种情况下，纸上原型是非常迅速且高效的，但是别期望可以得到更多的更深入的细节。而且不要给潜在用户展示纸上原型，仅仅只把它展示给团队成员。</p>
<p>视觉设计和交互设计是不能互换的，视觉设计是关于一个产品看起来怎么样，而交互设计是关于一个产品如何运作的。</p>
<h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><p>A/B测试（有时称为分桶测试或多变量测试）是指创建多个版本的界面或功能，并在真实产品环境中对不同的用户显示不同版本，以找出哪个版本的测试结果更好。</p>
<p>做设计评估最主要的原因是，可以知道你所做的改动对于公司而言，到底是起到了正面积极的作用，还是带来了负面的影响。</p>
<p>A/B测试的本质是，通过技术解决方案来解决设计问题，正是这一点使得它被大量的工程师文化浓厚的团队所采纳。</p>
<p>净推荐值是指有多少用户会向朋友推荐你的产品。虽然净推荐值是度量用户满意度的最佳指标，但它很难被精确收集。</p>
<p>只有在产品具有延迟注册机制的情况下，注册率才能算是衡量用户满意度的指标。</p>
<p>有时候就算得到的统计数据看上去非常显著，然而却并不具备统计学意义，原因是样本范围太小。</p>
<p>当你观察任何类型的实验或改动的结果时，你应该加入时间因素，看看在较长的时间范围内它将如何影响你的指标。</p>
<p>跨职能团队能起到很好的效果是因为每个人在相同的时间做相同的事情，这意味着信息在传递的过程中不会被混淆或丢失。</p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
      <category term="Reading Notes" scheme="https://zhulichao.github.io/categories/Reading-Notes/"/>
    
    
      <category term="Reading Notes" scheme="https://zhulichao.github.io/tags/Reading-Notes/"/>
    
  </entry>
  
  <entry>
    <title>WEB 自适应</title>
    <link href="https://zhulichao.github.io/2021/02/22/web-responsive/"/>
    <id>https://zhulichao.github.io/2021/02/22/web-responsive/</id>
    <published>2021-02-22T09:06:35.000Z</published>
    <updated>2021-08-11T08:16:24.315Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="多媒体查询"><a href="#多媒体查询" class="headerlink" title="多媒体查询"></a>多媒体查询</h2><p>主要针对不同的媒体类型(包括显示器、便携设备、电视机，等等)设置不同的样式规则，主要是页面布局或元素需要发生变化的情况，如从横向排列改为纵向排列，或使用不同图片等。</p>
<h2 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h2><p>可针对容器宽度自行调整元素位置，如果可以不限制元素宽高，自行充满。</p>
<h2 id="相对单位"><a href="#相对单位" class="headerlink" title="相对单位"></a>相对单位</h2><p>避免使用 px，使用 vh、vw、rem 等单位。使用 rem 的方式，可以采用工具进行自动的 px 到 rem 的转换。注意 <code>1px</code> 可以不转换，有时转换为 rem 会不显示，写成 <code>1PX</code> 即可不被转换。</p>
<h2 id="rem-方式实现"><a href="#rem-方式实现" class="headerlink" title="rem 方式实现"></a>rem 方式实现</h2><h3 id="安装-postcss-pxtorem"><a href="#安装-postcss-pxtorem" class="headerlink" title="安装 postcss-pxtorem"></a>安装 postcss-pxtorem</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install postcss-pxtorem --save-dev</div></pre></td></tr></table></figure>
<h3 id="配置-postcss-pxtorem"><a href="#配置-postcss-pxtorem" class="headerlink" title="配置 postcss-pxtorem"></a>配置 postcss-pxtorem</h3><p>添加 .postcssrc.js 文件如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="string">"plugins"</span>: &#123;</div><div class="line">    <span class="string">"autoprefixer"</span>: &#123;&#125;,</div><div class="line">    <span class="string">"postcss-pxtorem"</span>: &#123;</div><div class="line">      <span class="string">"rootValue"</span>: <span class="number">16</span>,</div><div class="line">      <span class="string">"propList"</span>: [</div><div class="line">        <span class="string">"*"</span></div><div class="line">      ],</div><div class="line">      <span class="string">"selectorBlackList"</span>: [<span class="string">"el-tooltip"</span>],</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="添加自适应代码"><a href="#添加自适应代码" class="headerlink" title="添加自适应代码"></a>添加自适应代码</h3><p>添加 rem.js 文件如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setRem</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> html = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'html'</span>)[<span class="number">0</span>];</div><div class="line">  <span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth; <span class="comment">// 获取窗口的文档显示区的宽度</span></div><div class="line">  <span class="keyword">var</span> font_Size = (<span class="number">16</span> / <span class="number">1920</span>) * width; <span class="comment">// 设计稿以1920为准，在1920的设计稿中：16px = 1rem</span></div><div class="line">  html.style.fontSize = font_Size + <span class="string">'px'</span>;</div><div class="line">  <span class="built_in">document</span>.documentElement.style.fontSize = font_Size + <span class="string">'px'</span>;</div><div class="line">&#125;</div><div class="line">setRem();</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, setRem);</div></pre></td></tr></table></figure>
<p>修改 main.js 文件如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">import <span class="string">'./utils/rem'</span>;</div><div class="line">...</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
      <category term="前端知识" scheme="https://zhulichao.github.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="前端知识" scheme="https://zhulichao.github.io/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Chrome 开发者工具</title>
    <link href="https://zhulichao.github.io/2021/02/03/chrome-devtools/"/>
    <id>https://zhulichao.github.io/2021/02/03/chrome-devtools/</id>
    <published>2021-02-03T01:41:36.000Z</published>
    <updated>2021-08-11T08:16:24.303Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>您已进入无痕模式调试性能相关的问题，禁用页面缓存，调整网络状态为 3G</p>
<ul>
<li>F5, Ctrl + R / Cmd + R，刷新页面</li>
<li>Ctrl + F5, Ctrl + Shift + R / Cmd + Shift + R，刷新页面并忽略缓存</li>
<li>Ctrl + ‘+’ / Cmd + Shift + ‘+’，放大 DevTools</li>
<li>Ctrl + ‘-‘ / Cmd + Shift + ‘-‘，缩小 DevTools</li>
<li>Ctrl + 0 / Cmd + 0，DevTools 恢复大小</li>
</ul>
<h2 id="模拟设备"><a href="#模拟设备" class="headerlink" title="模拟设备"></a>模拟设备</h2><img src="/2021/02/03/chrome-devtools/devices.jpg" title="模拟设备">
<p>打开调试工具，点击图中【1】所指图标可模拟设备，这个功能能够将你的浏览器变成任意一款移动设备，也能为你的网页设定宽高，点击 Edit… 可选择或添加常用设备。</p>
<h2 id="Elements-面板"><a href="#Elements-面板" class="headerlink" title="Elements 面板"></a>Elements 面板</h2><img src="/2021/02/03/chrome-devtools/elements.png" title="Elements面板">
<p>Elements 面板主要用于对页面 HTML 和 CSS 的检查以及可视化编辑，左上部分是一棵 DOM 树，左下部分是选中元素及所有父节点，右边是选中元素的样式。</p>
<h3 id="检查页面-DOM-元素"><a href="#检查页面-DOM-元素" class="headerlink" title="检查页面 DOM 元素"></a>检查页面 DOM 元素</h3><ul>
<li>右击页面任意一元素，选择检查</li>
<li>快捷键 Cmd + Opt + C，或点击图中【1】所指图标，在页面中选择元素</li>
<li>鼠标悬停 Elements 面板 DOM 树上的任意一个节点，页面会用淡蓝色的蒙板在页面上标记 DOM 节点对应的页面</li>
<li>按键盘的向上、向下键可以在展开的节点之间进行切换，向左、向右键可以收缩和展开节点</li>
</ul>
<p>点击图中【2】所指图标，Settings，Elements，勾上 Show user agent shadow DOM，可查看 placeholder 样式，如图中【3】所指。</p>
<h3 id="编辑-DOM"><a href="#编辑-DOM" class="headerlink" title="编辑 DOM"></a>编辑 DOM</h3><p>如图中【4】所示，选中 DOM 节点后，可双击或回车编辑，也可右键选择相应的菜单编辑。其中，Scroll into view 可让这个元素快速滚入视图中， Force state 可以触发并保持元素的伪类状态，Break on 可以添加 DOM 节点的监听，subtree modifications 表示子元素改变时、attribute modifications 表示属性改变时、node removal 表示元素被移除时。</p>
<p>在 Console 面板输入 <code>document.body.contentEditable=&quot;true&quot;</code>，可以直接对页面进行编辑。</p>
<h3 id="检查、编辑样式"><a href="#检查、编辑样式" class="headerlink" title="检查、编辑样式"></a>检查、编辑样式</h3><p><strong>Styles</strong> 面板，实时编辑与所选元素相关的样式，单击属性或者属性值可进行修改，按 Tab 键修改下一个属性或值，按 Tab + Shift 修改上一个属性或值。当值是数字类型时，按上下键可以以 1 为单位递增或递减，按 Alt + 上下键以 0.1 为单位递增或递减，Shift + 上下键以 10 为单位递增或递减。点击空白处可添加新的样式。</p>
<p>以 “Inherited from …” 为分界，上面的样式都是作用于元素本身的，下面的都是其继承而来的，继承的对象一般不止一个，可能是父元素，父元素的父元素…，将鼠标悬停在一个选择器上时，可以看到这个选择器所影响的所有页面元素（不包括可视区域外的元素）。</p>
<p>图中【5】所指部分，<code>:hov</code> 可触发并保持元素的伪类状态，用于查看伪类的 css 样式。<code>.cls</code> 可临时增删元素 class。<code>+</code> 可添加新的样式规则。</p>
<p>长时间悬停在某 CSS 类名上，会突出显示受该属性影响的所有节点。</p>
<p><strong>Event Listeners</strong> 面板，查看所选元素相关的监听事件。其中 Ancestors 不勾选则只显示直接定义在所选元素上的监听事件。Ancestors 后面为监听器类型，Blocking 为典型的那些过时的事件监听，Passive 指 Passive events listeners，是一个新的 web 标准，从 Chrome 51 开始添加的一个新特性，主要用来让页面滑动更加流畅。Framework listeners 检查来自框架的事件监听。右键事件监听，弹出菜单可以快速定位到源码。</p>
<p><strong>Computed</strong> 面板，检查、编辑所选元素的盒模型。</p>
<p><strong>Layout</strong> 面板，Grid 布局样式调试。</p>
<p><strong>DOM Breakpoints</strong> 面板，管理添加的 DOM 节点监听。</p>
<p><strong>Properties</strong> 面板，所选节点对应的对象及父类们。</p>
<p><strong>Accessibility</strong> 面板，查看 Accessibility Tree，无障碍树。</p>
<h2 id="Console-面板"><a href="#Console-面板" class="headerlink" title="Console 面板"></a>Console 面板</h2><img src="/2021/02/03/chrome-devtools/console.png" title="Console面板">
<p>Console 面板一方面用来记录页面在执行过程中的信息（一般通过各种 console 语句来实现），另一方面用来当做 shell 窗口来执行脚本以及与页面文档、DevTools等进行交互。</p>
<p>打开调试工具，可以看到 Console 面板，如果在其它面板下想同时看 Console，可以按 Esc 键，将 Console 以 “Drawer” 的形式打开。Console Drawer 中，Search 面板，可全局搜索代码，点击搜索结果，会跳到具体的源码文件。</p>
<p>图中【1】所指按钮为清空，可以通过快捷键 Ctrl L 清空 Console 面板，这个清空并不是真正意义的清空，还可以按向上向下的按键查看在 Console 中输入的历史。</p>
<p>图中【2】所指为执行环境选择器，除了当前的页面的执行环境，其它的框架、拓展都有其自己的执行环境，默认的执行环境是 “top”，点击下拉框还有其它选项，保持默认的 top 即可，如果想调试 iframe 可切换到指定的 iframe 环境。</p>
<p>图中【3】所指 Default levels 下拉框中勾选 Verbose，显示日志级别的信息，过滤框中输入 violation，可查看针对代码的最佳实践。</p>
<p>图中【4】创建一个动态监听，实时监听一个变量，如果变化了，这里也会变化，如输入 <code>Date.now()</code>。</p>
<p>Hide network：默认是不勾选的，Console 会报告网络问题，勾选这个功能就能过滤网络报告信息。</p>
<p>Preserve log：默认是不勾选的，如果勾选了，刷新页面之后信息还会被保留。</p>
<ul>
<li><code>$()</code> 作为 document.querySelector() 的缩写</li>
<li><code>$$()</code> 作为 document.querySelectorAll() 的缩写，返回一个数组</li>
<li><code>$0 ... $4</code>，代表 5 个最近访问过的 DOM 或者堆对象，$0 是最近访问的</li>
<li><code>$_</code> 记录了最后一次在表达式执行的结果</li>
</ul>
<p>在 Elements 标签页中选中一个页面元素，在 Console 标签页中，调用函数 <code>monitorEvents($0, &#39;click&#39;)</code>，第一个参数是当前元素（$0），第二个参数是事件名（click），按 Enter后，当被选中的元素触发了点击事件之后，Console 标签页会将该点击事件对象打印出来，调用 <code>unmonitorEvents($0)</code> 进行解绑。</p>
<p>如果要打印的变量是一个数组，每一个元素都是一个对象，可以使用 <code>console.table</code> 来打印，其表格化的呈现更加美观易读，如图中【5】所指。</p>
<p><code>copy()</code> 是一个工具函数方便将任何东西拷贝到系统的粘贴板暂存，传入一个没有格式的JSON，会返回格式化的结果，如图中【6】所指。</p>
<p><code>console.log()</code> 会在浏览器控制台打印出信息。</p>
<p><code>console.dir()</code> 可以显示一个对象的所有属性和方法。</p>
<h2 id="Application-面板"><a href="#Application-面板" class="headerlink" title="Application 面板"></a>Application 面板</h2><img src="/2021/02/03/chrome-devtools/clear.png" title="Clear site data">
<p>Application 面板查看应用信息、网页加载的所有资源，包括存储信息、缓存信息以及页面用到的图片、字体、脚本、样式等信息。</p>
<p>Ctrl Shift P，输入 clear，选择 Clear site data，在 Application 面板中 Storage 中可看到 Clear site data 按钮，一次性清除网站所有数据。</p>
<p>Frames 菜单中显示了该页面所有内容资源，顶级的 top 是一个主文档，在 top 下面是主文档的 Fonts、Images、Scripts、Stylesheets 等资源，最后一个就是主文件自身。在资源上右击后在弹出菜单选择 Reveal in Network Panel，就会跳转到 Network 面板并定位到该资源的位置。</p>
<h2 id="Network-面板"><a href="#Network-面板" class="headerlink" title="Network 面板"></a>Network 面板</h2><img src="/2021/02/03/chrome-devtools/network.png" title="Network面板">
<p>Network 面板可查看页面中各种资源请求的情况，如资源的名称、状态、使用的协议、资源类型、资源大小、资源时间线等情况，右键列头可以添加或隐藏列，可以根据这个进行网络性能优化。Network 面板主要分为3部分，分别为图中【1】【2】【3】，其中【3】所指为 Summary 概览，显示总的请求数、数据传输量、加载时间信息，下面详细说一下【1】【2】部分。</p>
<h3 id="Controls"><a href="#Controls" class="headerlink" title="Controls"></a>Controls</h3><p>图中【1】所指为 Controls 控制面板，控制 Network 的外观和功能。其中点击【4】所指过滤图标显示【6】所指过滤面板，Filter 输入框中可输入文本、正则表达式、属性过滤、<code>-</code> 开头表示取反，在显示的文件类型中，可按 Ctrl 键多选，WS 指 WebSocket，都是控制 Requests Table 具体显示哪些内容。Preserve log 勾选后刷新页面不清空 Network，Disable cache 勾选后禁用缓存。点击 Throttling 节流按钮，可模拟网络状态，默认值是 Online。点击【5】所指设置图标显示【7】所示更多控制选项，勾选 Show overview 会显示【8】所指面板，显示获取到资源的时间轴信息，其中蓝色竖线表示 DOMContentLoaded 事件被触发，并且在 Summary 以蓝色文字显示确切的时间，红色竖线表示 load 事件被触发，在 Summary 也会以红色文字显示确切的时间。勾选 Capture screenshots 重新加载页面即可捕获屏幕，双击其中的截屏可以放大显示，在放大的图下方可以点击跳转到上一帧或者下一帧，单击则可以查看该帧被捕获时的网络请求信息，并且在 Overview 上会有一条黄色竖线以标记该帧被捕获的具体时间点。</p>
<ul>
<li>DOMContentLoaded 事件会在页面上 DOM 完全加载并解析完毕之后触发，不会等待 CSS、图片、子框架加载完成</li>
<li>load 事件会在页面上所有 DOM、CSS、JS、图片完全加载完毕之后触发</li>
</ul>
<h3 id="Requests-Table"><a href="#Requests-Table" class="headerlink" title="Requests Table"></a>Requests Table</h3><p>图中【2】所指为 Requests Table 请求表格，按照请求的顺序排序，显示所有获取到的资源信息。点击一个请求的 Name 列可以了解更多信息，其中：</p>
<ul>
<li>Headers 该资源的HTTP头信息</li>
<li>Preview 根据你所选择的资源类型（JSON、图片、文本）显示相应的预览</li>
<li>Response 显示HTTP的Response信息</li>
<li>Cookies 显示资源HTTP的Request和Response过程中的Cookies信息</li>
<li>Timing 显示资源在整个请求生命周期过程中各部分花费的时间</li>
</ul>
<p>在 Timing 标签中可以显示资源在整个请求生命周期过程中各部分时间花费信息，可能会涉及到如下过程的时间花费情况：</p>
<ul>
<li>Queuing 排队的时间花费，可能由于该请求被渲染引擎认为是优先级比较低的资源（图片）、服务器不可用、超过浏览器的并发请求的最大连接数（Chrome的最大并发连接数为6）</li>
<li>Stalled 从HTTP连接建立到请求能够被发出送出去(真正传输数据)之间的时间花费，包含用于处理代理的时间，如果有已经建立好的连接，这个时间还包括等待已建立连接被复用的时间</li>
<li>Proxy Negotiation 与代理服务器连接的时间花费</li>
<li>DNS Lookup 执行DNS查询的时间，网页上每一个新的域名都要经过一个DNS查询，第二次访问浏览器有缓存的话，则这个时间为0</li>
<li>Initial Connection 建立连接的时间花费，包含了TCP握手及重试时间</li>
<li>SSL 完成SSL握手的时间花费</li>
<li>Request sent 发起请求的时间</li>
<li>Waiting (Time to first byte (TTFB)) 是最初的网络请求被发起到从服务器接收到第一个字节这段时间，它包含了TCP连接时间，发送HTTP请求时间和获得响应消息第一个字节的时间</li>
<li>Content Download 获取Response响应数据的时间花费</li>
</ul>
<p>通过按住 Shift 并且把光标移到请求行上，在该资源的上方第一个标记为绿色的资源就是该资源的发起者（请求源），有可能会有第二个标记为绿色的资源是该资源的发起者的发起者，以此类推，在该资源的下方标记为红色的资源是该资源的依赖资源，也就是对该资源的请求过程中引发了哪些资源，如下图所示。</p>
<img src="/2021/02/03/chrome-devtools/shift.png" title="按住shift">
<p>右键一个请求行，弹出菜单，其中：</p>
<ul>
<li>选择 Copy -&gt; Copy as fetch，复制为一个完整的 Fetch 请求的代码</li>
<li>选择 Block request domain 或 Block request URL，可以分别阻塞该请求所在 domain 下的所有请求 和 该请求</li>
</ul>
<h2 id="Sources-面板"><a href="#Sources-面板" class="headerlink" title="Sources 面板"></a>Sources 面板</h2><img src="/2021/02/03/chrome-devtools/sources.png" title="Sources面板">
<p>主要用来调试页面中的 JavaScript。Ctrl Shift P，输入 folding，选择 Enable code folding，或通过 Setting -&gt; Preferences -&gt; Sources，勾选 Code folding，可以在 Source 面板的编辑器和 Network 面板的 Preview 窗口下折叠 CSS 和 JavaScript 代码。设置断点可通过如下几种方式：</p>
<ul>
<li>在 JS 文件中输入 <code>debugger</code> js 文件运行的时候会在此处暂停</li>
<li>在 Sources 面板中打开文件，点击行号可添加断点，有时会出现行内断点，如【4】所示，点击即可激活，右键行号，Add condition breakpoints 可添加条件断点，Add logpoint 可快速注入一条 <code>console.log</code> 消息，设置的行断点可以在 Breakpoints 小窗口做统一管理</li>
<li>在 Elements 面板右键元素，Break on 可添加 DOM 断点</li>
<li>XHR/fetch Breakpoints 可添加 URL 包含某一字符串的断点，会在 XHR 调用 <code>send()</code> 那行代码的地方暂停</li>
<li>Event Listener Breakpoints 可勾选某一类别的事件或者是某一具体的事件添加事件监听器断点</li>
<li>点击图中【2】所指图标可在捕获的异常处暂停，未捕获的异常不考虑</li>
</ul>
<p>图中【1】所指按钮可停用所有断点，在不取消断点标记的情况下，使得所有断点失效；【3】所指按钮可将压缩的代码格式化显示。</p>
<p>当在某行代码暂停时，在调用栈窗口（Call Stack）的任意地方右键选择 Restart Frame，DevTools 会在调用栈 top 函数的第一行代码处暂停，top 函数就是指最后一个被调用的函数，在调用栈中位于最上面，所以叫 top 函数。可以在 Scope 窗口查看、编辑某些属性值和变量值，这些属性和变量按照作用域又分属在不同的地方，如局部作用域内、闭包内或者全局作用域内。在编辑器窗口打开对应的 js 文件中，可选择变量添加到 Watch 中进行监听，可在任意地方右键选择 Blackbox script 忽略该脚本文件，如第三方的库文件。可在 Settings -&gt; Blackboxing 中统一管理黑盒中的所有脚本文件。可在编辑器窗口直接修改文件，按Command+S(Mac)或者Ctrl+S保存修改，DevTools会重新编译脚本，继续在页面上进行某些操作，比如点击事件，就可以看到修改代码的效果了。Global Listeners 显示全局监听器，在浏览器中 window 是全局对象，所以在 Global Listeners 面板中显示绑定在 window 对象上的事件监听。</p>
<p>Overrides 子标签，选择 + Select folder for overrides，来为 Overrides 设置一个保存重写属性的目录，启用本地覆盖 ,面板上会显示你刚刚选择的文件夹。在 Page 子标签里选择你要修改的文件，Ctrl+S 保存修改，此时会在 Overrides 中你选择的文件夹下产生目录对应的本地副本文件。当存在本地副本时，本地覆盖启用，且工作空间下有该网站的同名覆盖文件，浏览器会优先执行覆盖文件。</p>
<p>Content scripts 指的是 Chrome 拓展注入在网页中的脚本。</p>
<p>Snippets 子标签来辅助 Debugging，以创建和保存小段代码的工具，比如 可以快速给任何应用添加lodash，右键可执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">    'use strict'</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">    element.src = <span class="string">"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.15.0/lodash.min.js"</span>;</div><div class="line">    element.type = <span class="string">"text/javascript"</span>;</div><div class="line">    <span class="built_in">document</span>.head.appendChild(element);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h2 id="Performance-面板"><a href="#Performance-面板" class="headerlink" title="Performance 面板"></a>Performance 面板</h2><p>Performance 面板可查看页面加载过程中的详细信息，不仅可以看到通过网络加载资源的信息，还能看到解析 JS、计算样式、重绘等页面加载的方方面面的信息。Cmd + Shift + N 打开 Chrome 的无痕模式，打开 <a href="https://googlechrome.github.io/devtools-samples/jank/" target="_blank" rel="external">在线DEMO</a> 链接，Cmd + Option + I 打开开发者工具，点击 Performance 面板。</p>
<img src="/2021/02/03/chrome-devtools/performance1.png" title="Performance面板">
<p>其中，【1】中三个按钮分别表示手动开始记录、自动重启页面并记录整个页面的加载过程、清除性能录制的记录，点击【2】按钮会进行一次垃圾回收，点击【3】Capture Settings（⚙️）按钮会展示更多设置来模拟各种状况，Disable JavaScript samples 选项勾选会使工具忽略记录 JS 的调用栈，Enable advanced paint instrumentation 选项勾选会详细记录某些渲染事件的细节，Network 选项可模拟网络状态，CPU选项可进行CPU限速。</p>
<p>点击左上角的 Record 按钮开始记录，然后模拟正常用户使用网页，点击 Stop 停止记录，生成性能报告。</p>
<img src="/2021/02/03/chrome-devtools/performance2.png" title="Performance报告">
<p>第一部分中，右测分别有 FPS、CPU、NET、HEAP：</p>
<ul>
<li>FPS 对应的是帧率，绿色代表帧率正常，绿色条越高，FPS 越高，红色代表帧率低，如果发现了一个红色的长条，那就说明这些帧存在严重问题，可能会降低用户体验，FPS ≥ 60性能最佳，FPS &lt; 24 会让用户感觉到卡顿</li>
<li>CPU 部分上有黄色、紫色、绿色等色块，它们的释义看图的左下角 Summary 标签，谁的占比高，说明 CPU 主要的时间花在哪里</li>
<li>NET 每条彩色横杠表示一种资源，横杠越长，检索资源所需的时间越长，每个横杠的浅色部分表示等待时间（从请求资源到第一个字节下载完成的时间）</li>
<li>HEAP 就是堆内存占用</li>
</ul>
<p>对于这个DEMO，可以很容易观察到性能问题，现在已经确定到这个页面的动画性能表现不太好，注意第四部分 Summary 面板中，也会发现CPU花费了大量的时间在 Rendering 上，提高性能就是一门做减法的艺术，目标就是减少 Rendering 的时间。</p>
<p>第二部分中，把鼠标移动到 Frames 的绿色条状上时，会展示这个帧的FPS。展开 Main 图表，展示了主线程运行状况，X轴代表着时间，每个长条代表着一个event，长条越长就代表这个event花费的时间越长，Y轴代表了调用栈，上面的event调用了下面的event。在事件长条的右上角出，如果出现了红色小三角，说明这个事件是存在问题的，需要特别注意。可使用键盘A键（选区轨迹左移）、D键（选区轨迹右移）、W键（缩小选区）、S键（增大选区）调整选择区域。</p>
<p>点击带有红色小三角的的事件，在 Summary 面板会看到详细信息，包括警告信息，如果存在 Reveal 的链接，双击它会让高亮触发这个事件的event，Reveal 下面是源码文件的链接，点击就会跳转到对应的代码处。点击 app.js:95 这个链接，就会跳转到对应的代码处，定位到是 update 方法造成的，但还不够明确。</p>
<img src="/2021/02/03/chrome-devtools/performance3.png" title="Performance报告">
<p>在 app.update 这个事件的长条下方，有很多被触发的紫色长条，放大这些事件长条，会看到它们每个都带有红色小三角，点击其中一个紫色事件长条，在 Summary 面板里展示了更多关于这个事件的信息。这里有“Forced reflow is a likely performance bottleneck.”警告，即强制回流可能是性能瓶颈，点击 Reveal 下面的源码链接 app.js:70 会跳转到需要优化的代码处。</p>
<img src="/2021/02/03/chrome-devtools/performance4.png" title="Performance报告">
<img src="/2021/02/03/chrome-devtools/performance5.png" title="源码文件">
<p>这段代码的问题在于，在每个动画帧中，它会更改每个方块的位置，然后查询页面上每个方块的位置，由于样式发生了变化，浏览器不知道每个方块的位置是否发生了变化，因此必须重新布局方块以计算其位置。优化代码是将 offsetTop 替换成 style.top，后者虽然取的是上一帧动画的元素位置，但并不影响计算下一帧动画位置，省去了重排获取位置的过程，减少了不必要的重排。</p>
<h2 id="Lighthouse-面板"><a href="#Lighthouse-面板" class="headerlink" title="Lighthouse 面板"></a>Lighthouse 面板</h2><img src="/2021/02/03/chrome-devtools/lighthouse1.png" title="Lighthouse 面板">
<img src="/2021/02/03/chrome-devtools/lighthouse2.png" title="Lighthouse 报告">
<p>从以下5个方面来对页面的加载进行分析，生成报告，然后给出提高页面性能的建议。</p>
<ul>
<li>Performance 性能检测，如网页的加载速度、响应时间等<ul>
<li>First Contentful Paint（FCP） 首次内容绘制时间</li>
<li>Speed Index（SI）速度指数，是一个页面加载性能指标，明显的页面填充的速度，此指标的分数越低越好</li>
<li>Largest Contentful Paint（LCP） 最大内容渲染时间，LCP是一个页面加载时长的技术指标，用于表示当前页面中最重要/占比最大的内容显示出来的时间点。不同于FCP，FCP代表的是第一次页面内容渲染的时间点，LCP是FCP的一个重要的补充，它可以代表当前页面主要内容展示的时间，LCP低于2.5s则表示页面加载速度优良</li>
<li>Time to Interactive（TTI）可互动时间，页面中的大多数网络资源完成加载并且CPU在很长一段时间都很空闲的所需的时间，此时可以预期CPU非常空闲，可以及时的处理用户的交互操作</li>
<li>Total Blocking Time（TBT）累积阻塞时长，TBT是一个衡量用户事件响应的指标，TBT会统计在FCP和TTI时间之间，主线程被阻塞的时间总和，当主线程被阻塞超过50ms导致用户事件无法响应，这样的阻塞时长就会被统计到TBT中，TBT越小说明页面能够更好的快速响应用户事件</li>
<li>Cumulative Layout Shift（CLS）累积布局变化量，CLS是一个衡量页面内容是否稳定的指标，CLS会将页面加载过程中非预期的页面布局的累积变动，CLS的分数越低，表明页面的布局稳定性越高，通常低于0.1表示页面稳定性良好</li>
</ul>
</li>
<li>Accessibility 无障碍使用，是指所创建的网站对所有用户都可用/可访问，不管用户的生理/身体能力如何、不管用户是以何种方式访问网站</li>
<li>Best practices 最佳实践，实践性检测，如网页安全性，如是否开启HTTPS、网页存在的漏洞等</li>
<li>SEO 搜索引擎优化，如网页 title 是否符合搜索引擎的优化标准等</li>
<li>Progressive Web App 离线应用检测</li>
</ul>
<p>点击 View Original Trace 按钮可进入 Performance 面板中进行进一步分析。</p>
<h2 id="Memory-面板"><a href="#Memory-面板" class="headerlink" title="Memory 面板"></a>Memory 面板</h2><img src="/2021/02/03/chrome-devtools/memory1.png" title="Memory面板">
<p>Memory 面板可以记录某个时刻的页面内存情况，一般用于分析性能问题、内存问题。推荐用户在创建堆快照时，不要在 Console 中执行代码，也不要启用调试断点。【1】表示开始记录，【2】表示清除，【3】表示进行一次垃圾回收。开始录制前先点击下垃圾回收，如果要查看JS堆内存动态分配时间线，结束之前要再点击下垃圾回收，再结束录制。</p>
<p><strong>Heap snapshot</strong> 用以打印堆快照，堆快照文件显示页面的 javascript 对象和相关 DOM 节点之间的内存分配，如下图所示。【1】可以选择查看内存快照的方式，【2】能够按照列出来的 Constructor 值进行筛选，【3】能够选择查看哪些阶段的对象，如 “Objects allocated before Snapshot1”、”Objects allocated between Snapshot1 and Snapshot2”。</p>
<p>内存快照的查看方式包括：</p>
<ul>
<li>Summary 总览视图，可以显示按构造函数名称分组的对象，使用此视图可以根据按构造函数名称分组的类型深入了解对象（及其内存使用），适用于跟踪 DOM 泄漏</li>
<li>Comparison 对比视图，可以显示两个快照之间的不同，比较两个（或多个）内存快照在某个操作前后的差异，检查已释放内存的变化和参考计数，可以确认是否存在内存泄漏及其原因</li>
<li>Containment 内容视图，此视图提供了一种对象结构视图来分析内存使用，由顶级对象作为入口，有助于分析对象的引用情况，适用于分析闭包以及深入分析对象</li>
<li>Statistic 统计视图，内存使用饼状的统计图</li>
</ul>
<p>内存快照信息中，各个字段代表信息如下：</p>
<ul>
<li>Constructor - 表示使用此构造函数创建的所有对象</li>
<li>Distance - 显示使用节点最短简单路径时距根节点的距离</li>
<li>Shallow Size - 显示通过特定构造函数创建的所有对象浅层大小的总和。浅层大小是指对象自身占用的内存大小（一般来说，数组和字符串的浅层大小比较大）</li>
<li>Retained Size - 显示同一组对象中最大的保留大小。保留大小指某个对象删除后（其依赖项不再可到达）可以释放的内存大小</li>
<li>#New - 对比视图下特有，新增项</li>
<li>#Deleted - 对比视图下特有，删除项</li>
<li>#Delta - 对比视图下特有，增量</li>
<li>Alloc. Size - 对比视图下特有，内存分配大小</li>
<li>Freed Size - 对比视图下特有，释放大小</li>
<li>Size Delta - 对比视图下特有，内存增量</li>
</ul>
<img src="/2021/02/03/chrome-devtools/memory2.png" title="Heap snapshot">
<p><strong>Allocation instrumentation on timeline</strong> 在时间轴上随着时间变化记录内存信息，显示了对象在什么时候被创建、什么时候存在内存泄漏。当勾选 Record allocation stacks 框后，还可以在 Allocation stack 面板里打印出调用堆栈。每条线的高度与最近分配的对象大小对应，竖线的颜色表示这些对象是否仍然显示在最终的堆快照中，蓝色竖线表示在时间线最后对象仍然显示，灰色竖线表示对象已在时间线期间分配，但曾对其进行过垃圾回收。可以重复执行某个动作，如果最后有不少蓝色柱被保留，这些蓝色柱就是潜在的内存泄露问题。</p>
<img src="/2021/02/03/chrome-devtools/memory3.png" title="Allocation instrumentation on timeline">
<p><strong>Allocation sampling</strong> 内存信息采样，使用采样的方法记录内存分配，可以查看哪些函数影响了内存的分配，并且该函数所耗内存在内存分配中占比多少，图中函数可以直接点击跳转到函数定义的文件和位置。【1】可以选择查看方式，其中：</p>
<ul>
<li>Chart，整个内存占用堆栈图信息，root是整个标签加载所需内存，向下逐步拆解形成的内存堆栈</li>
<li>Heavy，将堆栈图自底向上的罗列出来</li>
<li>Tree，将堆栈图自顶向下的罗列出来</li>
</ul>
<img src="/2021/02/03/chrome-devtools/memory4.png" title="Allocation sampling">
<h2 id="JavaScript-Profiler-面板"><a href="#JavaScript-Profiler-面板" class="headerlink" title="JavaScript Profiler 面板"></a>JavaScript Profiler 面板</h2><img src="/2021/02/03/chrome-devtools/profile.png" title="JavaScript Profiler">
<p>可以记录函数的耗时情况，方便找出耗时较多的函数，分析内存泄露。【1】可以选择查看方式，Chart 表示按时间先后顺序显示 CPU 性能，Heavy(Bottom Up) 根据对性能的消耗影响列出所有的函数，并可以查看该函数的调用路径，Tree(Top Down) 从调用栈的顶端（最初调用的位置）开始，显示调用结构的总体的树状图情况。</p>
<p>在 Chart 视图下，Overview 部分是整个录制结果的概览，柱形条的高度对应了调用堆栈的深度，也就是说柱形条高度越高，调用堆栈的深度越深。Call Stacks 部分在录制过程中被调用的函数的调用堆栈，横轴表示时间，纵轴表示调用栈，自上而下的表示函数的调用情况。视图中的函数颜色是随机显示的，相同的函数颜色标记是相同的。纵轴表示的函数调用堆栈高度仅仅是函数的调用嵌套层次比较深，不表示其重要性很高，但是横轴上一个很宽的柱形条则意味着函数的调用需要一个很长的时间去完成，那么就需要考虑去做一些优化了。将鼠标移到Call Stacks中的函数上可以显示如下信息：</p>
<ul>
<li>Name 函数名称</li>
<li>Self time 函数的本次调用运行的时间，不包含它所调用的子函数的时间</li>
<li>Total time 函数的本次调用运行的总时间，包含它所调用的子函数的运行时间</li>
<li>URL 函数定义在文件中所在的位置，其格式为file.js:100，表示函数在file.js文件中的第100行</li>
<li>Aggregated self time 在这次的录制过程中函数调用运行的总时间，不包含它所调用的子函数的时间</li>
<li>Aggregated total time 在这次的录制过程中所有的函数调用运行的总时间，包含它所调用的子函数的时间</li>
<li>Not optimized 如果优化器检测到该函数有潜在的优化空间，那么该函数会被列在这里</li>
</ul>
<h2 id="Rendering-面板"><a href="#Rendering-面板" class="headerlink" title="Rendering 面板"></a>Rendering 面板</h2><img src="/2021/02/03/chrome-devtools/rendering.png" title="Rendering面板">
<p>Rendering 面板页面的绘制时间。可通过点击 More tools -&gt; Rendering 打开，或者 ESC 弹出 Console Drawer 面板，点击左边竖形排列的三个小点，选择 Rendering 打开。</p>
<ul>
<li>Paint flashing 实时高亮重绘区域（绿色）</li>
<li>Layout Shift Regions 实时高亮重排，及重新布局区域（蓝色）</li>
<li>Layer Border 高亮成层用边框（橙色、橄榄色、青色）</li>
<li>Frame Rendering Stats，显示 GPU 的信息，旧版本还有实时 FPS 显示，但新版本不知道为何没有（chrome 86）</li>
<li>Scrolling performance issues 高亮可能会影响滚动性能的元素，这些元素主要指绑定了scroll事件和touch事件的元素</li>
<li>Highlight ad frames 高亮用于广告的 iframe</li>
<li>Hit-test borders 展示点击测试的区域</li>
<li>Emulate CSS media type 模拟媒体查询是打印还是终端屏幕</li>
<li>Emulate CSS media feature prefers-color-scheme 模拟媒体查询的系统主题</li>
<li>Emulate CSS media feature prefers-reduced-motion 模拟媒体查询的开启动画减弱功能</li>
<li>Emulate vision deficiencies 模拟色盲等视觉障碍</li>
</ul>
<h2 id="Layers-面板"><a href="#Layers-面板" class="headerlink" title="Layers 面板"></a>Layers 面板</h2><img src="/2021/02/03/chrome-devtools/layers.png" title="Layers面板">
<p>点击图中【1】所指按钮 ，More tools，Layers，展示页面中的分层情况的3D视图，可平移、旋转查看。</p>
<h2 id="Security-面板"><a href="#Security-面板" class="headerlink" title="Security 面板"></a>Security 面板</h2><img src="/2021/02/03/chrome-devtools/security.png" title="Security面板">
<p>通过该面板你可以去调试当前网页的安全和认证等问题并确保您已经在你的网站上正确地实现 HTTPS 和哪些内容没有通过 HTTPS 连接。</p>
<h2 id="Performance-monitor-面板"><a href="#Performance-monitor-面板" class="headerlink" title="Performance monitor 面板"></a>Performance monitor 面板</h2><img src="/2021/02/03/chrome-devtools/monitor.png" title="Performance monitor面板">
<p>Ctrl Shift P，输入 Show Performance Monitor 回车，可调出性能监视器，具有实时更新的可视化功能，能突出显示页面中的性能瓶颈。</p>
<h2 id="任务管理器"><a href="#任务管理器" class="headerlink" title="任务管理器"></a>任务管理器</h2><img src="/2021/02/03/chrome-devtools/memory0.png" title="任务管理器">
<p>浏览器右上角三个点的符号 -&gt; 更多工具 -&gt; 任务管理器，主要关注内存占用空间、Javascript使用的内存，Javascript使用的内存默认不显示，可以点击右键添加，可结束指定进程。</p>
<ul>
<li>内存占用空间，表示本机内存，DOM节点存储在本机内存中，如果这个值在增加，则说明正在创建DOM节点。</li>
<li>JavaScript 使用的内存，表示JS堆，这一列包含两个值，关注实际使用大小即可（括号中的数字），跳动的数字表示您网页上的可获得的对象正在使用多少内存，如果这个数字在增加，那说明正在创建新对象，或现有对象正在增长。</li>
</ul>
<p>如果内存占用空间一直在增长但JS内存不增长，可能是浏览器还没有回收，不操作闲置一段时间看下是否会下降。如果是内存占用空间在增长，但JS内存增长得很缓慢，有可能是有JS变量引用了DOM，这个DOM节点本身不大，但影响了其他DOM节点(比如父级节点树)。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>浏览器窗口地址栏中输入 <code>chrome://flags/</code>，可以看到实验性的功能。</p>
<p>Settings 中，Experiments 菜单，勾选 CSS Overview，可以看到页面的 CSS 统计信息。</p>
<img src="/2021/02/03/chrome-devtools/css-overview.png" title="CSS Overview">
<p>Settings 中，Experiments 菜单，勾选 Record coverage while performance tracing，在 Performance 面板进行性能录制时可选择捕获代码覆盖率。Coverage 录制结果展示了录制过程中加载的所有 JS 和 CSS 文件以及每个文件的的大小、运行时覆盖率，红色表示未执行，绿色表示已执行。</p>
<img src="/2021/02/03/chrome-devtools/coverage.png" title="Coverage">
<p>Settings 中，Experiments 菜单，勾选 Automatically pretty print in Sources Panel，开启自动美化代码模式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
      <category term="前端知识" scheme="https://zhulichao.github.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="前端知识" scheme="https://zhulichao.github.io/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>vue-dynamic-component</title>
    <link href="https://zhulichao.github.io/2021/01/15/vue-dynamic-component/"/>
    <id>https://zhulichao.github.io/2021/01/15/vue-dynamic-component/</id>
    <published>2021-01-15T01:34:57.000Z</published>
    <updated>2021-08-11T08:16:24.302Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用动态组件实现菜单加载逻辑，并通过 mixin 提取公用部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;component</div><div class="line">      :is=&quot;item&quot;</div><div class="line">      v-for=&quot;(item, index) in components&quot;</div><div class="line">      :key=&quot;item + index&quot;</div><div class="line">      :ref=&quot;item&quot;</div><div class="line">    /&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">import Vue from &apos;vue&apos;;</div><div class="line">import &#123; mapActions &#125; from &apos;vuex&apos;;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  props: &#123;</div><div class="line">    components: &#123;</div><div class="line">      type: Array,</div><div class="line">    &#125;,</div><div class="line">  &#125;,</div><div class="line">  created() &#123;</div><div class="line">    if (this.components &amp;&amp; this.components.length &gt; 0) &#123;</div><div class="line">      this.components.forEach(component =&gt; &#123;</div><div class="line">        Vue.component(component, resolve =&gt;</div><div class="line">          require([`@/views/map/dynamicComponents/$&#123;component&#125;`], response =&gt; &#123;</div><div class="line">            response.default.mixins = response.default.mixins || [];</div><div class="line">            response.default.mixins.push(&#123;</div><div class="line">              created() &#123;</div><div class="line">                this.$store.dispatch(&apos;AddDynamicComponent&apos;, &#123;</div><div class="line">                  name: component,</div><div class="line">                  handleClose: this.handleClose,</div><div class="line">                &#125;);</div><div class="line">              &#125;,</div><div class="line">            &#125;);</div><div class="line">            resolve(response);</div><div class="line">          &#125;, () =&gt; &#123;</div><div class="line">            console.error(`未找到 @/views/map/dynamicComponents/$&#123;component&#125;`);</div><div class="line">          &#125;)</div><div class="line">        );</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    ...mapActions([&apos;AddDynamicComponent&apos;]),</div><div class="line">  &#125;,</div><div class="line">&#125;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
      <category term="Vue" scheme="https://zhulichao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://zhulichao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>git-fork-sync</title>
    <link href="https://zhulichao.github.io/2021/01/08/git-fork-sync/"/>
    <id>https://zhulichao.github.io/2021/01/08/git-fork-sync/</id>
    <published>2021-01-08T02:34:25.000Z</published>
    <updated>2021-08-11T08:16:24.300Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="fork-项目"><a href="#fork-项目" class="headerlink" title="fork 项目"></a>fork 项目</h2><ul>
<li>打开 <a href="https://git.gitedit.com:8081/gis-platform/epipe-vp-web" target="_blank" rel="external">epipe-vp-web</a> ，点击 Fork</li>
<li>选择一个空间即可</li>
<li>Settings -&gt; General -&gt; Advanced settings，修改项目名称和 Path</li>
</ul>
<img src="/2021/01/08/git-fork-sync/fork.jpg" title="Fork 项目">
<h2 id="clone-项目"><a href="#clone-项目" class="headerlink" title="clone 项目"></a>clone 项目</h2><ul>
<li>git clone 新项目地址， 默认分支为 master</li>
<li>cd epipe-vp-web-new</li>
<li>git remote add upstream <a href="https://git.gitedit.com:8081/gis-platform/epipe-vp-web.git" target="_blank" rel="external">https://git.gitedit.com:8081/gis-platform/epipe-vp-web.git</a></li>
<li>git checkout -b project-name 作为项目开发用</li>
</ul>
<h2 id="更新项目"><a href="#更新项目" class="headerlink" title="更新项目"></a>更新项目</h2><img src="/2021/01/08/git-fork-sync/fork-old.jpg" title="分支关系">
<h3 id="epipe-vp-web"><a href="#epipe-vp-web" class="headerlink" title="epipe-vp-web"></a>epipe-vp-web</h3><ul>
<li>在 business 分支开发</li>
<li>git checkout develop</li>
<li>git merge business</li>
<li>git push</li>
<li>git checkout master</li>
<li>git merge develop</li>
<li>git push</li>
</ul>
<h3 id="新项目"><a href="#新项目" class="headerlink" title="新项目"></a>新项目</h3><ul>
<li>git checkout master</li>
<li>git fetch upstream</li>
<li>git merge upstream/master</li>
<li>git push</li>
<li>git checkout project-name</li>
<li>git merge master</li>
</ul>
<img src="/2021/01/08/git-fork-sync/relation.jpg" title="分支关系">
<ul>
<li>有没有可能出现，同时开发 A、B 两个项目，同时需要业务平台修改，添加 featureA、featureB 功能？</li>
<li>其实新项目可以拉取原项目的任意分支</li>
</ul>
<h2 id="多次-fork"><a href="#多次-fork" class="headerlink" title="多次 fork"></a>多次 fork</h2><p>同一组下只能 fork 一次，若想达到 fork 多次的效果，可以通过如下两种方式：</p>
<h3 id="删除与源项目的-fork-关系"><a href="#删除与源项目的-fork-关系" class="headerlink" title="删除与源项目的 fork 关系"></a>删除与源项目的 fork 关系</h3><ul>
<li>Settings -&gt; General -&gt; Advanced settings -&gt; Remove fork relationship</li>
</ul>
<h3 id="通过-git-命令初始化"><a href="#通过-git-命令初始化" class="headerlink" title="通过 git 命令初始化"></a>通过 git 命令初始化</h3><ul>
<li>git clone <a href="https://git.gitedit.com:8081/gis-platform/epipe-vp-web.git" target="_blank" rel="external">https://git.gitedit.com:8081/gis-platform/epipe-vp-web.git</a></li>
<li>git remote rename origin upstream</li>
<li>git remote add origin <a href="https://git.gitedit.com:8081/zhulichao/epipe-fork.git" target="_blank" rel="external">https://git.gitedit.com:8081/zhulichao/epipe-fork.git</a></li>
<li>git push -u origin —all</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
      <category term="Git" scheme="https://zhulichao.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://zhulichao.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>https-public-path</title>
    <link href="https://zhulichao.github.io/2021/01/06/https-public-path/"/>
    <id>https://zhulichao.github.io/2021/01/06/https-public-path/</id>
    <published>2021-01-06T06:24:26.000Z</published>
    <updated>2021-08-11T08:16:24.300Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="技术平台"><a href="#技术平台" class="headerlink" title="技术平台"></a>技术平台</h2><p>借鉴 qiankun 的思路，如果项目中使用了 publicPath ，需要给 window 添加 <code>__INJECTED_PUBLIC_PATH_BY_EPIPE__</code> 全局变量，然后技术平台需要引用静态资源的地方都拼接上这个变量。</p>
<ul>
<li>入口文件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Viewer</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> __PUBLIC_PATH__;</div><div class="line">  <span class="comment">// 入口方法</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">async</span> createDefaultViewer(id, callback = GisComponent.BaseMap.flyToChina) &#123;</div><div class="line">    <span class="keyword">this</span>.__PUBLIC_PATH__ =</div><div class="line">      <span class="built_in">window</span>.__INJECTED_PUBLIC_PATH_BY_EPIPE__ || <span class="built_in">window</span>.__INJECTED_PUBLIC_PATH_BY_QIANKUN__ || <span class="string">''</span>;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>webpack 配置文件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">  ...</div><div class="line">  <span class="string">'CESIUM_BASE_URL'</span>: <span class="string">'(window.__INJECTED_PUBLIC_PATH_BY_EPIPE__ || window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__ || "") + "/static/cesium"'</span>,</div><div class="line">&#125;),</div></pre></td></tr></table></figure>
<h2 id="业务平台后台端"><a href="#业务平台后台端" class="headerlink" title="业务平台后台端"></a>业务平台后台端</h2><ul>
<li>添加 VUE_APP_BASE_API 环境变量，作为为静态的 publicPath</li>
<li>入口文件 main.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加，判断一下有没有通过 iframe 引用后台端项目</span></div><div class="line"><span class="built_in">window</span>.__INJECTED_PUBLIC_PATH_BY_EPIPE__ = parent.__INJECTED_PUBLIC_PATH_BY_EPIPE__ || process.env.VUE_APP_PUBLIC_PATH;</div><div class="line"><span class="keyword">if</span> (parent.__INJECTED_PUBLIC_PATH_BY_EPIPE__) &#123;</div><div class="line">  <span class="comment">// eslint-disable-next-line</span></div><div class="line">  __webpack_public_path__ = parent.__INJECTED_PUBLIC_PATH_BY_EPIPE__ + <span class="string">'/'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>路由文件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</div><div class="line">  base: process.env.VUE_APP_PUBLIC_PATH, <span class="comment">// 添加</span></div><div class="line">  scrollBehavior: () =&gt; (&#123; y: <span class="number">0</span> &#125;),</div><div class="line">  routes: constantRoutes,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>vue.config.js 配置文件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">publicPath: process.env.VUE_APP_PUBLIC_PATH || <span class="string">'/'</span>,</div><div class="line">chainWebpack(config) &#123;</div><div class="line">  <span class="comment">// 重新定义环境变量</span></div><div class="line">  config.plugin(<span class="string">'define'</span>).tap(args =&gt; &#123;</div><div class="line">    args[<span class="number">0</span>][<span class="string">'process.env'</span>].VUE_APP_PUBLIC_PATH = <span class="string">'(parent.__INJECTED_PUBLIC_PATH_BY_EPIPE__ || "'</span> + process.env.VUE_APP_PUBLIC_PATH + <span class="string">'")'</span>;</div><div class="line">    args[<span class="number">0</span>][<span class="string">'process.env'</span>].VUE_APP_BASE_API = <span class="string">'(parent.__INJECTED_PUBLIC_PATH_BY_EPIPE__ || "'</span> + process.env.VUE_APP_PUBLIC_PATH + <span class="string">'") + "'</span> + process.env.VUE_APP_BASE_API + <span class="string">'"'</span>;</div><div class="line">    args[<span class="number">0</span>][<span class="string">'process.env'</span>].VUE_APP_MODEL_URL = <span class="string">'(parent.__INJECTED_PUBLIC_PATH_BY_EPIPE__ || "'</span> + process.env.VUE_APP_PUBLIC_PATH + <span class="string">'") + "'</span> + process.env.VUE_APP_MODEL_URL + <span class="string">'"'</span>;</div><div class="line">    args[<span class="number">0</span>][<span class="string">'process.env'</span>].VUE_APP_LAYER_URL = <span class="string">'(parent.__INJECTED_PUBLIC_PATH_BY_EPIPE__ || "'</span> + process.env.VUE_APP_PUBLIC_PATH + <span class="string">'") + "'</span> + process.env.VUE_APP_LAYER_URL + <span class="string">'"'</span>;</div><div class="line">    <span class="keyword">return</span> args;</div><div class="line">  &#125;);</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="业务平台用户端"><a href="#业务平台用户端" class="headerlink" title="业务平台用户端"></a>业务平台用户端</h2><ul>
<li>添加 VUE_APP_BASE_API 环境变量，作为为静态的 publicPath</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># 生产环境配置</div><div class="line">ENV = 'production'</div><div class="line"></div><div class="line"># 若依管理系统/生产环境</div><div class="line">VUE_APP_PUBLIC_PATH = ''</div><div class="line"></div><div class="line">VUE_APP_BASE_API = '$&#123;VUE_APP_PUBLIC_PATH&#125;/prod-api'</div><div class="line"></div><div class="line">VUE_APP_MODEL_API = '$&#123;VUE_APP_PUBLIC_PATH&#125;/model/model/'</div><div class="line"></div><div class="line">VUE_APP_LAYER_URL = '$&#123;VUE_APP_PUBLIC_PATH&#125;/model/layer/'</div></pre></td></tr></table></figure>
<ul>
<li>入口文件 main.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加</span></div><div class="line"><span class="built_in">window</span>.__INJECTED_PUBLIC_PATH_BY_EPIPE__ = process.env.VUE_APP_PUBLIC_PATH;</div></pre></td></tr></table></figure>
<ul>
<li>路由文件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</div><div class="line">  base: process.env.VUE_APP_PUBLIC_PATH, <span class="comment">// 添加</span></div><div class="line">  scrollBehavior: () =&gt; (&#123; y: <span class="number">0</span> &#125;),</div><div class="line">  routes: constantRoutes,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>vue.config.js 配置文件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">publicPath: process.env.VUE_APP_PUBLIC_PATH || <span class="string">'/'</span>,</div><div class="line">chainWebpack(config) &#123;</div><div class="line">  <span class="comment">// 拷贝静态资源</span></div><div class="line">  config.plugin(<span class="string">'copy'</span>).use(CopyWebpackPlugin, [</div><div class="line">    [</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">from</span>: <span class="string">'./static'</span>,</div><div class="line">        to: <span class="string">'static'</span>,</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">from</span>: <span class="string">'node_modules/epipe-vp-web-cms/static/cms'</span>,</div><div class="line">        to: <span class="string">'static/cms'</span>,</div><div class="line">        ignore: [<span class="string">'.*'</span>],</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">from</span>: <span class="string">'node_modules/epipe-vp-web-cms/static/images'</span>,</div><div class="line">        to: <span class="string">'static/images'</span>,</div><div class="line">        ignore: [<span class="string">'.*'</span>],</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">from</span>: <span class="string">'node_modules/epipe-vp-web-cms/index.html'</span>,</div><div class="line">        to: <span class="string">'static/cms'</span>,</div><div class="line">        ignore: [<span class="string">'.*'</span>],</div><div class="line">        transform (content, path) &#123;</div><div class="line">          <span class="keyword">let</span> str = content.toString();</div><div class="line">          <span class="comment">// 路径替换，添加 VUE_APP_PUBLIC_PATH 环境变量</span></div><div class="line">          str = str.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/(\/static\/cms)/g</span>), process.env.VUE_APP_PUBLIC_PATH + <span class="string">'/static/cms'</span>);</div><div class="line">          <span class="keyword">return</span> str;</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">    ],</div><div class="line">  ]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
      <category term="Webpack" scheme="https://zhulichao.github.io/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="https://zhulichao.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>qiankun 集成</title>
    <link href="https://zhulichao.github.io/2020/12/04/qiankun-base/"/>
    <id>https://zhulichao.github.io/2020/12/04/qiankun-base/</id>
    <published>2020-12-04T07:39:29.000Z</published>
    <updated>2021-08-11T08:16:24.300Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><a href="https://qiankun.umijs.org/zh" target="_blank" rel="external">qiankun（乾坤）</a> 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。</p>
</blockquote>
<p>开发环境下，集成 qiankun 比较简单，常规项目也没什么问题。但是我们的项目有些特殊性，主要原因是使用了已经打完包的技术平台，技术平台中有授权校验，又使用了 cesium 地图相关的功能。</p>
<p>生产环境部署还没测！！！</p>
<h2 id="特殊包-mapv-的引用报错"><a href="#特殊包-mapv-的引用报错" class="headerlink" title="特殊包 mapv 的引用报错"></a>特殊包 mapv 的引用报错</h2><p>业务平台，用户端使用了技术平台，后台端也使用了技术平台，火星科技引用的 mapv 包，在加载后会注册全局变量 window.L，内部对 L 有一些判断逻辑，进入用户端时 L 已经被注册了，再进入后台端，L 已经存在，导致 mapv 内部的判断逻辑会出错。解决方案如下，在进入后台端前卸载 L 变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">registerMicroApps(</div><div class="line">  [</div><div class="line">    &#123;</div><div class="line">      name: <span class="string">'vue'</span>,</div><div class="line">      entry: <span class="string">'//localhost:1024'</span>,</div><div class="line">      container: <span class="string">'#container'</span>,</div><div class="line">      activeRule: genActiveRule(<span class="string">'/cms'</span>),</div><div class="line">    &#125;,</div><div class="line">  ],</div><div class="line">  &#123;</div><div class="line">    beforeLoad: () =&gt; &#123;</div><div class="line">      <span class="built_in">window</span>.L = <span class="literal">undefined</span>;</div><div class="line">    &#125;,</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="请求静态资源报错"><a href="#请求静态资源报错" class="headerlink" title="请求静态资源报错"></a>请求静态资源报错</h2><p>src/assets 下的资源，或者通过 import 加载的 static 下的静态资源，都会经过打包编译，是没有问题的。但是直接引用 static 下的资源路径，就会找不到。解决办法是在这些直接引用的静态资源前面添加 <code>window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__</code> 变量。</p>
<h2 id="cesium-CESIUM-BASE-URL-变量"><a href="#cesium-CESIUM-BASE-URL-变量" class="headerlink" title="cesium CESIUM_BASE_URL 变量"></a>cesium CESIUM_BASE_URL 变量</h2><p>因为 cesium 是被技术平台引用的，经过打包后被业务平台引用的，cesium 的 CESIUM_BASE_URL 变量的定义是在技术平台中定义的，也需要定义成动态的值才能在经过 qiankun 引用时找到。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'CESIUM_BASE_URL'</span>: <span class="string">'window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__ + "/static/cesium"'</span>,</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
      <category term="Project Base" scheme="https://zhulichao.github.io/categories/Project-Base/"/>
    
    
      <category term="Project Base" scheme="https://zhulichao.github.io/tags/Project-Base/"/>
    
  </entry>
  
  <entry>
    <title>business-platform</title>
    <link href="https://zhulichao.github.io/2020/11/23/business-platform/"/>
    <id>https://zhulichao.github.io/2020/11/23/business-platform/</id>
    <published>2020-11-23T05:41:21.000Z</published>
    <updated>2021-08-11T08:16:24.298Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>epipe-vp-web 用户端项目，epipe-vp-web-cms 后台项目。这两个项目独立开发，epipe-vp-web-cms 打包后，发布到 npm 上。epipe-vp-web 通过 npm install 安装后台项目，通过 iframe 引用后台项目，iframe 无法直接引用 node_modules 下的资源，可以通过 webpack 配置，将打包后的静态文件拷贝到当前项目中，iframe 就能引到了。</p>
<h2 id="Vuex-结构"><a href="#Vuex-结构" class="headerlink" title="Vuex 结构"></a>Vuex 结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  modules: &#123;</div><div class="line">    user, <span class="comment">// 登录相关、用户信息</span></div><div class="line">    permission, <span class="comment">// 根据路由生成菜单信息</span></div><div class="line">    userConfig, <span class="comment">// 用户设置，主题、布局等</span></div><div class="line">    checkedLayer, <span class="comment">// 图层树中已勾选的图层</span></div><div class="line">    checkedProject, <span class="comment">// 项目过滤中已勾选的项目</span></div><div class="line">    companyInfo, <span class="comment">// 公司信息</span></div><div class="line">    createdModal, <span class="comment">// 已经初始化的 Modal 弹框，可全局控制关闭</span></div><div class="line">    currentPage, <span class="comment">// 当前页面</span></div><div class="line">  &#125;,</div><div class="line">  getters,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="巧用-css"><a href="#巧用-css" class="headerlink" title="巧用 css"></a>巧用 css</h2><p>select 用图片回填，可以用 css 绝对定位将要显示的元素，也就是图片，放在 select 输入框元素的上面，设置 <code>pointer-event: none;</code> 将鼠标事件穿透，来正常触发 select 点击事件。</p>
<p>底图切换按钮，将 cesium 底图切换按钮用绝对定位放在自定义底图按钮下层，将图片透明度设置为 0，自定义的底图按钮设置 <code>pointer-event: none;</code> 将鼠标事件穿透，来触发 cesium 底图切换按钮。这时功能是没问题的，但是因为将自定义底图按钮的鼠标事件穿透了，也无法触发 hover 和 active 样式，效果不好。处理方式是将自定义底图按钮通过 <code>visibility: hidden;</code> 隐藏起来，cesium 底图按钮除了图片透明度为 0，还需要用 <code>:after</code> 设置按钮中的文字，背景色设置成按钮一样可切换主色，就实现了自定义底图按钮的效果。</p>
<h2 id="iView-按需引用"><a href="#iView-按需引用" class="headerlink" title="iView 按需引用"></a>iView 按需引用</h2><p>项目里，除了主要使用的组件库，如 element-ui，其它使用的组件库，尽量使用按需引用，减少打包后的体积。</p>
<h2 id="Modal-组件"><a href="#Modal-组件" class="headerlink" title="Modal 组件"></a>Modal 组件</h2><p>基于 el-dialog 组件进行封装，在 mounted 中根据传入的 left、right 等值，设置 Modal 的位置，<code>this.$refs.mapModal.$refs.dialog.style.setProperty(&#39;top&#39;, this.top);</code> ，在 watch 中监听 left、right 等参数的变化修改位置。使用 setProperty 是因为这种方式可以设置样式的 <code>!important</code>。</p>
<p>在全局状态管理中管理 Modal，在 created 的时候将 Modal 的名字和关闭的回调函数添加到 vuex 中，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">created() &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.addCloseToStore) &#123;</div><div class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">'AddCreatedModal'</span>, &#123;</div><div class="line">      name: <span class="keyword">this</span>.name,</div><div class="line">      handleModalClose: <span class="keyword">this</span>.handleModalClose,</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>在 vuex 中有关闭所有 Modal、关闭指定的多个 Modal、关闭除指定外的所有 Modal 的事件。</p>
<h2 id="Modal-避让"><a href="#Modal-避让" class="headerlink" title="Modal 避让"></a>Modal 避让</h2><p>在要打开多个 Modal 的组件中，定义一个记录当前打开 Modal 的数组，每次打开一个 Modal 时调用 handleModalShow 方法将要打开的 Modal 的名字和宽度放入数组中，并调用 reCalculateLeft() 方法计算 left 值，该值时传入 Modal 组件的参数。每次关闭 Modal 时将数组中的对应元素去掉，并调用所有 Modal 对应的 reCalculateLeft() 方法重新计算位置，页面中添加动画。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">handleModalShow(refName) &#123;</div><div class="line">  <span class="keyword">let</span> position = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">this</span>.openedModal.forEach((item, index) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (item.name === <span class="keyword">this</span>.$refs[refName].name) &#123;</div><div class="line">      position = index;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.openedModal.push(&#123;</div><div class="line">      name: <span class="keyword">this</span>.$refs[refName].name,</div><div class="line">      width: <span class="keyword">this</span>.$refs[refName].width,</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">this</span>.$refs[refName].handleShow();</div><div class="line">  &#125;</div><div class="line">&#125;,</div><div class="line">handleModalClose(name) &#123;</div><div class="line">  <span class="keyword">let</span> position = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">this</span>.openedModal.forEach((item, index) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (item.name === name) &#123;</div><div class="line">      position = index;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">if</span> (position &gt; <span class="number">-1</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.openedModal.splice(position, <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>.$refs.pbsTreeModal &amp;&amp; <span class="keyword">this</span>.$refs.pbsTreeModal.reCalculateLeft();</div><div class="line">  <span class="keyword">this</span>.$refs.pbsIntroductionModal &amp;&amp; <span class="keyword">this</span>.$refs.pbsIntroductionModal.reCalculateLeft();</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<h2 id="添加新模块"><a href="#添加新模块" class="headerlink" title="添加新模块"></a>添加新模块</h2><ul>
<li><p>/src/views/map/components 中添加新模块，如文件名为 XXX，有 handleOpen 方法入口</p>
</li>
<li><p>/src/views/map/header/Content/index.vue 中添加新组件 XXX 的引用</p>
</li>
<li><p>菜单管理中，需要有一个名为“用户端菜单”的菜单，它下面添加的菜单会显示在用户端Header中</p>
</li>
<li><p>菜单管理中，添加新菜单，路由地址中填入 XXX，与文件名或文件夹名保持一致</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>technology-platform</title>
    <link href="https://zhulichao.github.io/2020/11/23/technology-platform/"/>
    <id>https://zhulichao.github.io/2020/11/23/technology-platform/</id>
    <published>2020-11-23T01:37:58.000Z</published>
    <updated>2021-08-11T08:16:24.299Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="结构简介"><a href="#结构简介" class="headerlink" title="结构简介"></a>结构简介</h2><p>技术平台 epipe-visual-engine 项目，其实是三个项目，一个是 EVECesium 项目，一个是 EVEThree 项目，一个是网站项目。我们是通过一套代码，或者说是一个代码仓库，来维护的这三个项目，通过配置 webpack，打包后也是生成三个包。</p>
<img src="/2020/11/23/technology-platform/folder.jpg" width="400" title="目录结构">
<ul>
<li>/app 下是网站代码</li>
<li>/EVECesium 是 cesium API 代码</li>
<li>/EVEThree 是 three.js API 代码</li>
<li>/build/app 是打包网站的配置</li>
<li>/build/EVECesium 是打包 cesium API 的配置</li>
<li>/build/EVEThree 是打包 three.js API 的配置</li>
<li>/dist_app 是网站打包后的文件</li>
<li>/dist_EVECesium 是 cesium API 打包后的文件，可发布到 npm 安装使用</li>
<li>/dist_EVEThree 是 three.js API 打包后的文件，可发布到 npm 安装使用</li>
<li>/static/app 是网站中使用的静态资源</li>
<li>/static/doc 是使用 jsdoc 生成的静态文件，里面分别有 EVECesium、EVEThree 目录</li>
<li>/static/EVECesium 是 cesium API 使用的静态资源，如地图上的图片</li>
<li>/static/EVEThree 是 three.js API 使用的静态资源，如模型上的图片</li>
<li>/jsdoc 下是使用 jsdoc 根据注释生成的静态文件的自定义配置</li>
<li>/build/generateLicense.js 文件是生成秘钥的脚本，被 <code>npm run generateLicense</code> 命令引用</li>
</ul>
<h2 id="授权简介"><a href="#授权简介" class="headerlink" title="授权简介"></a>授权简介</h2><img src="/2020/11/23/technology-platform/authorization.jpg" title="授权逻辑">
<h3 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h3><p><code>npm run generateLicense</code> 将 /static/license 明文文件加密后生成 /license 文件，拷贝到需要的项目即可。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"modules"</span>: [</div><div class="line">    <span class="string">"EVECesium"</span>,</div><div class="line">    <span class="string">"EVEThree"</span></div><div class="line">  ],</div><div class="line">  <span class="attr">"type"</span>: <span class="string">"permanent"</span>,</div><div class="line">  <span class="attr">"domains"</span>: [</div><div class="line">    <span class="string">"localhost"</span>,</div><div class="line">    <span class="string">"127.0.0.1"</span>,</div><div class="line">    <span class="string">"192.168.70.119"</span>,</div><div class="line">    <span class="string">"192.168.70.69"</span></div><div class="line">  ],</div><div class="line">  <span class="attr">"created"</span>: <span class="string">"2020-08-11"</span>,</div><div class="line">  <span class="attr">"expired"</span>: <span class="string">"60"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>modules 表示授权的包，可为多个</li>
<li>本项目或业务平台引用指定 type 为 permanent，添加 domains 为本地域名</li>
<li>生产环境指定 type 为 production，添加 domains 为域名或IP加端口</li>
<li>开发环境指定 type 为 development，添加 created 创建时间、expired 过期天数</li>
</ul>
<h3 id="解密逻辑、输出版权信息"><a href="#解密逻辑、输出版权信息" class="headerlink" title="解密逻辑、输出版权信息"></a>解密逻辑、输出版权信息</h3><p>EVECesium 或 EVEThree 中读入 static/license 文件，校验逻辑放在 static/EVECesium/validate 中，输出版权信息放在 static/EVECesium/info 中。解密逻辑和输出版权信息，在 epipe-visual-engine 项目中看到的，是明文的文件，但是在打包后生成的是加密后的文件。上面三个文件读入后，都需要执行解密逻辑，然后通过 eval 执行 validate 校验和输入版权信息。</p>
<p>再说 static/license 正常应该是加密后的授权文件，在技术平台自身的项目 epipe-visual-engine 中，为了维护方便，static/license 是明文文件，就像 validate 和 info 文件一样，通过 webpack 插件 copy-webpack-plugin 打包后生成加密后的文件。</p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 Lottie 加载动画</title>
    <link href="https://zhulichao.github.io/2020/11/10/lottie-web/"/>
    <id>https://zhulichao.github.io/2020/11/10/lottie-web/</id>
    <published>2020-11-10T03:29:09.000Z</published>
    <updated>2021-08-11T08:16:24.298Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基于 lottie ，将 After Effects 导出的 json 文件渲染成 svg/canvas/html 动画效果。我使用的是 <a href="https://github.com/airbnb/lottie-web" target="_blank" rel="external">lottie-web</a>。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>npm install lottie-web --save</code></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div id=&quot;lottie_box&quot; class=&quot;login-form-container&quot; /&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">import lottie from &apos;lottie-web&apos;;</div><div class="line">import * as animationData from &apos;@/assets/image/login-data.json&apos;;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  mounted() &#123;</div><div class="line">    lottie.loadAnimation(&#123;</div><div class="line">      container: document.getElementById(&apos;lottie_box&apos;),</div><div class="line">      renderer: &apos;svg&apos;,</div><div class="line">      loop: true,</div><div class="line">      autoplay: true,</div><div class="line">      animationData: animationData.default,</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">&#125;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
      <category term="JavaScript" scheme="https://zhulichao.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://zhulichao.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>css-border-overlap</title>
    <link href="https://zhulichao.github.io/2020/11/06/css-border-overlap/"/>
    <id>https://zhulichao.github.io/2020/11/06/css-border-overlap/</id>
    <published>2020-11-06T05:59:43.000Z</published>
    <updated>2021-08-11T08:16:24.298Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="css-处理边框叠加"><a href="#css-处理边框叠加" class="headerlink" title="css 处理边框叠加"></a>css 处理边框叠加</h2><p>如图所示，想要做一个按钮组的功能，有 hover 效果。</p>
<img src="/2020/11/06/css-border-overlap/buttons.jpg" title="按钮组">
<p>如果做一个 ul 列表，然后给每个 li 加上边框，相邻列表的边框就会变成 2px，解决方法是给 li 在样式中指定 <code>margin-right: -1px;</code> 这样两个边框就可以重叠在一起了。</p>
<p>但是在这个 li 加了 hover 后，鼠标悬停让边框变色，每个变色的只会是上下左三条框，右边框被盖住，看不出效果了，解决方法是给 li 在 hover 时提高层级，就达到了想要的效果。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">li</span> &#123;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#FF0000</span>;</div><div class="line">   <span class="attribute">margin-right</span>: -<span class="number">1px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#0000FF</span>;</div><div class="line">   <span class="attribute">position</span>: relative;</div><div class="line">   <span class="attribute">z-index</span>: <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="css-让点击穿透"><a href="#css-让点击穿透" class="headerlink" title="css 让点击穿透"></a>css 让点击穿透</h2><p>pointer-event: none; // 点击穿透<br>pointer-event: auto; // 恢复点击</p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
      <category term="CSS" scheme="https://zhulichao.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://zhulichao.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>自文档化代码</title>
    <link href="https://zhulichao.github.io/2020/10/10/self-documenting-code/"/>
    <id>https://zhulichao.github.io/2020/10/10/self-documenting-code/</id>
    <published>2020-10-10T01:45:18.000Z</published>
    <updated>2021-08-11T08:16:24.297Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="自文档化代码（Self-Documenting-Code）"><a href="#自文档化代码（Self-Documenting-Code）" class="headerlink" title="自文档化代码（Self Documenting Code）"></a>自文档化代码（Self Documenting Code）</h2><ul>
<li>不需要额外的编写、维护文档或注释的工作</li>
<li>文档或注释要随着代码更新，维护版本，多了不好管理</li>
<li>文档或注释会增加人们的阅读量</li>
<li>不要编写需要外部文档支持的代码</li>
<li>唯一能完整并正确地描述代码的文档就是代码本身</li>
</ul>
<h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><ul>
<li>变量、函数名语义化</li>
<li>避免过多地嵌套语句</li>
<li>要谨慎地优化代码，防止它不再清晰地表达基础的算法</li>
<li>结构化，分解为原子函数</li>
<li>把条件表达式换成函数或变量</li>
<li>选择有描述型的类型</li>
<li>命名常量</li>
<li>提供必要的、有意义的注释，如复杂逻辑</li>
<li>恰当的处理错误</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《面向对象的思考过程》笔记</title>
    <link href="https://zhulichao.github.io/2020/09/27/object-oriented/"/>
    <id>https://zhulichao.github.io/2020/09/27/object-oriented/</id>
    <published>2020-09-27T06:11:58.000Z</published>
    <updated>2021-08-11T08:16:24.297Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>面向对象的思考过程是一个非常优秀的设计理念。它可以独立于语言存在。如果你熟练掌握了面向对象的思考过程，那么就可以轻松地在不同的面向对象的语言之间切换。</p>
</blockquote>
<p>既然函数式编程这么好，为什么这几年的发展只能算是波澜不惊，没有掀起大风浪呢？</p>
<ul>
<li>首先面向对象的思考过程更加符合大家对世界的直观感受，毕竟不是每个人都是数学家</li>
<li>其次是面向对象的编程范式和函数式编程的范式并不是完全对立的，一些语言既有函数式的特点，也有面向对象的特点</li>
</ul>
<p>历史上定义面向对象的语言拥有：<strong>封装（encapsulation）、继承（inheritance）、多态（polymorphism）</strong>的特点，我也会加入组合的特点。</p>
<p><strong>开发人员面临的问题一直就是如何将新的面向对象技术与现有的系统集成起来。</strong></p>
<p>包装对象是指在面向对象的类中包含其他代码。例如，可以将结构化代码包装到一个对象内部，使其行为就像对象一样。</p>
<p><strong>究竟什么是对象？一个对象由两部分组成：属性及行为，对象的基本定义是一个包含了数据和行为的实体。</strong></p>
<p>在面向对象的设计中，属性及行为包含在单个对象中，而在过程式或结构式设计中，属性和行为通常是分开的。</p>
<p>结构化编程中数据往往与程序分离，而且数据是全局的，所以在你的代码作用域之外依然可以很容易修改数据。</p>
<p>如果设计是恰当的，那么在面向对象模型中则不会有诸如全局数据的元素。事实上，在面向对象系统中具有很高的数据完整性。</p>
<p>对象包含整型和字符串之类的实体，用于表示属性，对象也包含方法，用于表示行为。在对象中，方法用于操作数据及其他行为。更重要的是，你可以控制对对象中成员（包括属性及方法）的访问。</p>
<p>在面向对象的术语中，数据表现为属性，行为表现为方法。限制访问具体属性和（或）方法的行为叫做数据隐藏。将属性及方法合并到同一个实体中，在面向对象中将这种方式叫做封装。</p>
<p>对象不应当操作其它对象的内部数据。</p>
<p>使用面向对象技术的程序本质上是对象的集合。</p>
<p>存放在对象中的数据代表了该对象的状态。在面向对象数据中，数据被称为属性。</p>
<p>对象的行为表示对象可以做什么。在面向对象程序设计术语中，这些行为包含在方法中，你可以通过发送消息的方式来调用方法。</p>
<p>使用对象最强大、最有趣的一点在于，数据与行为是一个整体，而不是与行为代码割裂。</p>
<p>XML 的出现并不全为了以可移植的方式表示数据。它也有一种替代方式起来让代码轻松访问数据。</p>
<p><strong>取值方法和赋值方法的理念就是数据隐藏。</strong></p>
<p>每个类图有三部分组成：类名、数据（属性）、行为（方法）。</p>
<p>请注意没必要为每个对象的每个方法都实现一个物理副本。其实，每个对象指向了同一个实现。</p>
<p>类是对象的蓝图。当你实例化一个对象时，你基于类来构建这个对象。</p>
<p>类可以认为是对象的模板或者模具。</p>
<p>类的数据通过属性来表示。每个类必须定义属性，用来存放该类实例化的每个对象的状态。</p>
<p>在任何情况下，对对象中属性的访问应该由该对象自身控制，任何一个对象都不应该直接修改其它对象的属性。</p>
<p>消息是对象之间的通信机制。例如，当对象A调用了对象B的一个方法，对象A向对象B发送了一个消息。对象B的响应由其返回值定义。</p>
<p>对象仅暴露必要的接口来和其它对象进行交互。除了如何使用该对象，其它细节都应当对其它对象隐藏起来。</p>
<p>数据隐藏是封装的主要部分。</p>
<p>为了实现数据隐藏，必须将所有属性声明为 private。属性绝不是接口的一部分。只有 public 方法是类接口的一部分。</p>
<p>请注意类有接口，方法也有接口。</p>
<p>注意在该类图中，加号（+）表示 public 访问修饰符，而减号（-）表示 private 访问修饰符。</p>
<p>面向对象程序设计的最强大的功能之一就是代码重用。</p>
<p>一个类只能有一个父类称为单继承，一个类可以有多个父类称为多重继承。</p>
<p>多态是一个希腊词，字面上理解为许多形状。在继承体系图中，所有的子类从它们的超类中继承接口。然而，由于每个子类是单独的实体，每个子类需要对同一个消息有单独的应答。</p>
<p>重载（overriding）的基本释义是子类覆盖父类中的一个实现。总之，每个类能够对同一个Draw方法返回不同的响应来绘制自己。这正是多态的意义。</p>
<p>如果方法被定义为abstract，子类必须提供该方法的实现。</p>
<p>如果方法名与类名相同，并且没有返回值，这个方法就是一个特殊的方法，称为构造函数。可以认为构造函数是类的入口，对象在这里被构造。构造函数里可以进行初始化操作和执行一些启动任务。</p>
<p>如果子类继承了父类的一个抽象方法，它必须提供该方法的具体实现，否则它自身也必须是个抽象类。</p>
<p>使用其他对象来构建或结合成新的对象，这种方式就是组合。</p>
<p>我想说只有两种方式来使用其他类构建新类，这两种方式就是继承和组合。我们最好用has-a术语来描述组合关系。</p>
<p>在设计一个系统甚至一个类之前，先思考问题本身。</p>
<p><strong>培养面向对象的思考过程的良好习惯需要注意三个方面：</strong></p>
<ul>
<li>清楚接口和实现之间的区别。</li>
<li>深入理解抽象。</li>
<li>给用户提供尽可能少的接口。</li>
</ul>
<p>当设计类时，应该向用户暴露什么、隐藏什么是非常重要的。</p>
<p>接口与类直接相关。终端用户通常看不到任何类，只会看到GUI或者命令行。程序员会接触类接口。</p>
<p>正确地设计类时要注意两部分，即接口和实现。</p>
<p>作为一个通用的规则，一个类的接口应该只包含需要用户知道的东西。</p>
<p>当设计类时最重要的考虑就是识别类的读者（或用户）。</p>
<p>实现细节对于用户是隐藏的。我们必须时刻牢记关于实现的一个目标，那就是修改实现不需要变动用户代码。</p>
<p>接口包含了调用方法及返回值的语法。</p>
<p>如果一个方法是公共方法，那么程序员就可以访问它，因此可以认为它是类的接口。</p>
<p>只提供给用户绝对需要的东西。这以为着接口要尽可能少。最好只有用户真正需要时才添加接口，不要提供超出用户需求的接口。</p>
<p>公共接口定义了用户可以访问什么。</p>
<p>从用户角度定义类至关重要，而不是从信息系统的角度定义类。</p>
<p>确保设计类时你向真正的用户了解了需求和设计。</p>
<p>我们已经确定用户是实际使用这个系统的人。那么，谁是用户？</p>
<p>需要从每个用户的视角来开始识别每个对象的目的以及需要做的事情。</p>
<p>环境限制往往都是影响因子。</p>
<p>刚开始，你只需要考虑如何使用这个对象，不用考虑如何构建这个对象。</p>
<p>很多面向对象的文章推荐每个接口模型只包含一个行为。这带给我们的问题是我们的设计究竟要抽象到哪种层次。</p>
<p>从技术角度来讲，任何非公共接口可以视为实现。这意味着用户不会看到具体的实现方法。</p>
<p>类可能有一些私有方法仅供内部使用。任何私有方法都可以视为实现的一部分，用户绝不会看到它，从而也不能访问它。</p>
<p>公共方法中的代码是实现的一部分，因为用户不能看到它。</p>
<p>理论上来说，任何对实现的修改都不应该影响用户通过接口与类的交互方式。</p>
<p>构造函数名称与类名相同。构造函数没有返回值。如果有返回值，编译器就不认为该方法是构造函数。</p>
<p>new关键字创建了Cabbie类的一个新实例，这会按需分配内存。然后会调用构造函数自身，并且可以通过参数列表传递参数。开发人员可以在构造函数内进行相应的初始化工作。</p>
<p>构造函数最重要的功能大概是当遇到new关键字时初始化内存分配。总之，构造函数中的代码会把新创建的对象初始化到稳定、安全的状态。</p>
<p>初始化属性是构造函数经常执行的功能。</p>
<p>如果没有为类提供一个显示的构造函数，那么类会有一个默认构造函数。请记住，无论你是否自定义了构造函数，类始终至少有一个构造函数。如果你没有提供构造函数，系统会为你提供一个默认的构造函数。</p>
<p>除了创建对象本身之外，默认构造函数的另一个行为是调用父类的构造函数。</p>
<p>在类中始终包含至少一个构造函数式一个优秀的实践。如果类有属性，最好始终在构造函数中初始化这些属性。延伸开来，无论是否在编写面向对象的代码，初始化变量总是一个优秀的实践。</p>
<p>通用规则是即使并不需要在构造函数中做任何事情，也应当始终提供一个构造函数。你可以提供一个不包含任何代码的构造函数，稍后再按需添加代码。尽管使用编译器默认提供的构造函数在技术上没有任何问题，但基于文档化和维护目的，这样更容易看懂你的代码。</p>
<p>如果你使用的是默认的构造函数，后续操作添加了另一个构造函数，那么系统不会再创建默认的构造函数。总之，只有类中没有包含任何构造函数时，系统才会添加默认的构造函数。一旦你提供了一个构造函数，系统就不再提供默认的构造函数。</p>
<p>重载可以让程序员重复使用相同的方法名，只要每次方法签名不同即可。方法签名包含了方法名以及参数列表。</p>
<p>当使用继承时，你必须知道如何构造父类。请记住，当使用继承时，也继承了父类的所有东西。因此必须熟悉父类的数据和行为。任何继承的属性都是完全可见的。然而，对构造函数的继承则是不可见的。</p>
<p>如果遇到new关键字，那么会分配对象，并发生以下步骤：</p>
<ul>
<li><p>在构造函数中会调用父类的构造函数。如果没有显示调用父类的构造函数，那么系统会默认自动调用。</p>
</li>
<li><p>对象中的所有属性会被初始化。</p>
</li>
<li><p>执行构造函数中的其余代码。</p>
</li>
</ul>
<p>不要依赖编译器来初始化属性。</p>
<p>构造函数用来确保应用程序处于稳定的状态。</p>
<p>优秀的实践应该是为所有属性识别一个稳定的状态，然后在构造函数中初始化这些属性为稳定的状态。</p>
<p>程序中有三种基本的解决方案来处理发现的问题：修复问题、通过压制来忽略问题，或以合适的方式退出运行时。</p>
<ul>
<li>忽略该问题。这不是好主意！</li>
<li>检查潜在的问题，当发现问题时中止程序。</li>
<li>检查潜在的问题，捕获错误并试图修复该问题。</li>
<li>抛出异常（通常这是处理异常的最佳方式）。</li>
</ul>
<p>不应该忽略任何已知的问题。可以让系统收拾残局并进入稍微稳定的状态，比如关闭文件和强制系统重启。</p>
<p>检查潜在问题，捕获错误，并试图恢复的方案远胜于简单地检查问题并中止程序的方案。</p>
<p>并不总能在错误第一次发生的地方就能探测到该错误。</p>
<p>这里的关键概念是用特定的代码块用来处理特定的异常。这既解决了尝试找出错误发生的地方的问题，也解决了在正确的地方处理该错误的问题。</p>
<p>在 Java 中，try 代码块中抛出了异常，catch 代码块会处理该异常。</p>
<ul>
<li>try 代码块会结束执行</li>
<li>catch 从句会检查对应的 catch 代码块能否处理这种异常。（一个 try 代码块可能会对应多个 catch 从句）</li>
<li>如果所有 catch 代码块都不能处理抛出的异常，那么该异常会传递给最近的更高一层的 try 代码块中（如果代码中没有捕获该异常，系统最终会捕获它，结果是无法预料的，可能导致应用程序崩溃）。</li>
<li>如果有一个 catch 从句匹配上了（遇到了第一个匹配的从句），会执行 catch 从句中的代码。</li>
<li>程序会从紧挨着 try 代码块的下面的代码处恢复执行。</li>
</ul>
<p>每个类可以实例化出多个对象。每个对象有唯一的标识和状态。这点很关键。会给每个单独构造的对象分配独立的内存。然而，一个类实例化的多个对象可以共享类中一些属性和方法，从而共享为这些属性和方法分配的内存。</p>
<p>构造函数是一个被类的所有实例共享的方法，这是共享方法的一个好例子。</p>
<p>对象有三种属性：</p>
<ul>
<li>局部属性，由特定的方法拥有</li>
<li>对象属性</li>
<li>类属性</li>
</ul>
<p>属性（和方法）存在于特定的作用域中。</p>
<p>关键字 this 是对当前对象的一个引用。</p>
<p>static 类型的变量，从该类中实例化的所有对象只会为该属性分配一块单独的内存。每个类只有一个副本，该类的所有对象共享该副本。</p>
<p>操作符重载允许你修改一个操作符的含义。</p>
<p>近代面向对象的语言（不如Java、.NET 和 Objective-C）不允许重载操作符。</p>
<p>与操作符重载一样，Java、.NET 和 Objective-C 的设计者认为多重继承带来的系统的复杂度超过了带来的好处，因此从语言层面消除了多重继承。Java、.NET 和 Objective-C 语言提供的接口构造能力在某些方面能弥补这一点。但 Java、.NET 和 Objective-C 不允许传统的多重继承。</p>
<p>接口是行为继承的一种机制，抽象类则用于实现继承。编程语言中的接口类型提供不同行为的接口，但不提供实现，而抽象类既提供接口，也能提供实现。</p>
<p><strong>复杂的数据结构和对象的问题在于它们可能会包含引用。简单对引用的复制不能复制它引用的数据结构或对象。同样，当比较对象时，简单地比较两个指针只是比较了引用，而并未比较指针所指的对象。</strong></p>
<p><strong>追踪所有的引用，并对所有引用对象都创建拷贝，这种方式称为深拷贝。浅拷贝只会简单地拷贝引用，而不会深入层级。</strong></p>
<p>当设计类时，你应当在类中提供一个比较功能，从而保证类的行为是预期的。</p>
<p>最明显的原因是类名用来识别类本身。除了简单的识别作用之外，类名必须是描述性的。选择一个合适的名称相当重要，因为类名提供了这个类的用途以及在大系统中的交互方式等信息。</p>
<p>把属性设置为不存在的值是非常有用的编程技术。检查变量是否为 null 可以识别该值是否正确初始化。检查属性是否为 null 也是一个优秀的编程实践。</p>
<p>构造函数都定义为 public，这是因为构造函数很显然是类接口的成员。如果构造函数是私有的，其它对象就不能访问它们，从而无法实例化对象。</p>
<p>最重要的原因是保证数据完整性以及高效调试。</p>
<p>赋值方法可以在某种程度确保数据的完整性。这也可以解决安全问题。因此通过取值方法和赋值方法来访问数据可以提供一种机制用于密码检查或其它验证技术。这极大地增加了数据的完整性。</p>
<p>如果属性是静态的，而且类为该属性提供了一个赋值方法，其它对象调用该赋值方法只会修改同一个副本。</p>
<p>构造函数和访问器都被定义为公共的，并且属于公共接口的一部分。对外暴露它们是因为它们是使用该类的重要方式。</p>
<p>我最喜爱的有关类设计指导及建议的其中一本书是《Effective C++:50 Specific Ways to Improve Your Programs and Designs》。</p>
<p>在设计类时最重要的问题是保持公共接口最小化。提供最小化的公共接口可以保证类尽可能地简单。</p>
<p>隐藏实现的原因已经阐述得非常详细了。改变类的实现不应该影响到用户，这才是设计良好的类。</p>
<p>但我认为把所有终端用户当做实际客户是相当重要的，而且你必须满足他们的要求。</p>
<p>Gilbert 和 McCarty 指出封装的最高指导原则是”所有字段都应该是私有的“。在这种方式下，其他对象无法直接访问类中的任何字段。</p>
<p>当设计类时，最重要的设计问题之一是如何构造类。首先并且最重要的一点是，构造函数应该把对象设置为安全的初始状态。</p>
<p>在包含构造函数的语言中，析构函数包括了正确的清除功能，这也很重要。</p>
<p>通用规则是应用程序应当绝不崩溃。当系统遭遇错误时，应当自身修复错误并继续执行，或者在不丢失用户的任何重要数据情况下友好地退出。</p>
<p>没有优秀的文档实践是不可能驱动出优秀的设计的。优秀的设计的最重要的方面之一是，设计类时应该小心地记录过程。</p>
<p>几乎没有完全隔离的类，几乎没有任何原因来构建一个不需要与其他类交互的类。</p>
<p>确定哪些属性和方法可声明为静态的相当重要。这些属性和方法会被类的所有对象共享。</p>
<p>为类、属性和方法遵循命名约定也是同一目的。有很多命名约定，你选择哪种约定并不重要，重要的是选择一个并始终遵守。当选择了一种约定后，确保当你新建类、属性和方法时，你不仅遵循了约定，而且名称具有含义。确保这些约定是有意义的，每个相关的人都能理解背后的意图。</p>
<p>保持命名具有描述性是优秀的开发实践，无论哪种开发范式中的都要执行这项实践。</p>
<p>最小化全局数据是优秀的编程风格，这并不特定于面向对象编程。全局数据在结构化开发中是允许的，但它们是危险的。</p>
<p>swap() 方法的作用域内需要 temp 属性。没有理由将 temp 属性放置到类级别。因此，你应该把 temp 的作用域移动到 swap() 方法的作用域中。</p>
<p>高度依赖其他类的行为被称为高度耦合。即如果修改一个类会强迫修改另一个类，那么这两个类则可以说是高度耦合的。</p>
<p>在大多数设计和编程过程中，一般都推荐使用迭代过程。基本上，这意味着不要一次性写完所有代码！用小步增长的方式来编写代码，每步都进行构建和测试。</p>
<p>测试人员更喜欢用迭代过程，因为他们可以在早期就参与进来。</p>
<p>接口的最小实现通常称为桩（stub）。</p>
<p>当使用完桩后，不要删除它。保留桩以便后续使用。确保用户不能看到它们。</p>
<p>系统可以被定义为相互交互的类。</p>
<p>创建优秀的设计最重要的因素是找到一个你和你的组织都感到舒服的方式并且坚持使用它。实现一个没人愿意遵循的设计没有任何意义。</p>
<p>通常一个稳固的面向对象的设计过程包含以下步骤：</p>
<ul>
<li>进行正确的分析</li>
<li>编写工作陈述文档来描述该系统</li>
<li>通过规格说明收集需求</li>
<li>开发用户接口的原型</li>
<li>识别类</li>
<li>确定每个类的职责</li>
<li>确定类与类之间如何交互</li>
<li>创建一个高层次的模型来描述系统的构建</li>
</ul>
<p>彻底测试软件确保绝对没有任何缺陷存在是不可能的。</p>
<p>在分析阶段，如果没有有效的理由来做该项目，那么可以毫不犹豫地中止该项目。</p>
<p>工作陈述（SOW)是描述系统的文档。</p>
<p>Visual Basic.NET 是一个创建原型的非常棒的环境。</p>
<p>我认为作为一名优秀的程序员意味着理解基本的编程逻辑，并且对写代码充满激情。</p>
<p>将一个现有的类包装到一个新类中，以便修改它的实现或接口。</p>
<p>最困难及最有趣的设计决策就是决定使用继承还是组合。</p>
<p>正确做法是应该始终测试新代码。每个新的继承关系使用继承而来的方法时会创建新的上下文。完整的测试策略是基于这些上下文做测试。</p>
<p>该概念有时被称为通用到特例，这是使用继承时的又一个重要的考虑因素。</p>
<p>在大型系统中，尽可能保持简单往往是最佳实践。过于精确的模型无法维持较低的复杂度。决定在设计时引入更小的复杂度或者更多的功能是一项平衡艺术。</p>
<p>当前还有未来的开销因素也是决策的主要因素。</p>
<p>对象组合的经典例子是汽车。</p>
<p>本书中，UML 中的聚合以带线的菱形表示，比如引擎是汽车的一部分。联合则只有一根线（没有菱形）表示。</p>
<p>封装是面向对象的本质，所以它是面向对象设计的基本原则之一。继承也是三个主要的面向对象概念之一。然而，继承在某种方式上实际上破坏了封装！</p>
<p>继承意味着对其他类的强封装，但是弱化了父类和其子类之间的封装。</p>
<p>多态是对继承的最优雅的使用之一。实体类自身负责实现功能。</p>
<p>子类不能从协议继承任何代码。因此协议用法与抽象类不是完全相同的，所以设计对象模型时要考虑这一点。</p>
<p>接口、协议和抽象类是代码重用的重要机制，提供了所谓契约这一功能。</p>
<p>面向对象的拥护者鼓吹面向对象的主要优势就是一次编写，多次重用。</p>
<p>创建可重用的代码的方式之一是使用框架。</p>
<p>框架可以实现插拔机制和重用准则。它也能让开发者最大化地重用代码，而且可以重用界面设计。</p>
<p>编写类或类库的人应该提供文档来介绍如何使用这些类和类库（至少我们希望他这样做）。通常这些文档代表了应用程序编程接口（API）。</p>
<p>我们定义契约为要求开发人员遵循API规格要求的一种机制。</p>
<p>如果不强制遵守，一些淘气的程序员会决定重新发明轮子来自己实现代码，而不会使用框架提供的规格说明。</p>
<p>实现契约的方式之一是使用抽象类。抽象类包含一个或多个没有提供任何实现的方法。</p>
<p>假设我们想创建一个应用程序来绘制形状。我们的目标是绘制产品设计中包含的所有类型的形状，以后还可以添加新的形状。那么必须遵循两个条件。</p>
<ul>
<li>首先所有形状必须使用相同的语法来绘制自生</li>
<li>其次请记住每个类必须要响应自身的行为</li>
</ul>
<p>向对象发送消息，不同的对象会得到不同的响应，这是多态的本质。</p>
<p>如果我们想让 Shape 类包含所有可能的（当前的以及以后加入的）形状代码，那么需要一些条件语句（比如 Case 语句）。这会非常杂乱，而且难以维护。</p>
<p>如果 Circle 继承自 Shape 但没有提供 draw() 方法，对 Circle 类的编译会失败。这是因为 Circle 没有满足 Shape 的契约。</p>
<p>如果 Circle 没有实现 draw() 方法，那么可以认为它自身是抽象的。那么另一个子类必须继承自 Circle 并且实现 draw() 方法。该子类则成为 Shape 和 Circle 类的实体实现。</p>
<p>请记住对抽象类的定义是它包含一个或多个抽象方法，这暗示了抽象类也可以提供实体方法。</p>
<p>这些抽象方法就是契约。</p>
<p>契约不适合用于组合情况（或者 has-a 关系）。</p>
<p>第一，当涉及用户交互的可视化接口（比如显示器）时，会广泛使用图形化用户接口（GUI）。</p>
<p>第二，类的接口基本上是指其方法签名。</p>
<p>第三，在 Objective-C 语言中，接口和实现会将代码在物理上分割为不同的模块。</p>
<p>第四，Java 中的接口和 Objective-C 的协议本质上是父类和子类之间的契约。</p>
<p>使用多个抽象类构成了多重继承。如果设计上是合理的，理论上你可以为任何类添加接口。而抽象类要求你继承自该抽象类，并且延伸至其自身所有可能的父类。</p>
<p>基于这些考虑，接口往往作为缺少多重继承情况下的一种替代方案。但接口并不是替代或回避使用多重继承。</p>
<p>接口不像抽象类，它完全不能提供任何实现。所以任何实现某个接口的类必须提供实现所有方法。</p>
<p>有时继承被称为实现继承，而接口被称为定义继承。</p>
<p>抽象类可以提供抽象方法，也可以提供实体方法，而接口只能提供抽象方法。为什么要有这样的区别呢？</p>
<ul>
<li>狗是哺乳动物，所以 Dog 和 Mammal 之间的关系是继承关系</li>
<li>Dog 实现了 Nameable，所以它们之间是接口关系</li>
<li>狗有头，所以 Dog 和 Head 之间是组合关系</li>
</ul>
<p>尽管接口是继承的特殊类型，但了解特殊之处是非常重要的。理解这特殊之处是设计出强壮的面向对象系统的关键。</p>
<p>虽然继承时严格的 is-a 关系，但接口不是。</p>
<p>接口可被应用到不相关的类。你可以给狗命名，也可以给蜥蜴命名。这是使用抽象类和使用接口的关键区别。</p>
<p>接口指定了没有明显联系的类之间的相同行为。</p>
<p>所以我们可以安全地说狗是有名字的实体。这是简单但有效的证据，继承和接口都构成 is-a 关系。</p>
<p>首先，很多情况下开发系统时甚至并未考虑重用。其次，即使考虑到了重用，计划限制、有限的资源以及经费考虑等问题经常干扰最佳实践。</p>
<p>使用组合的另一个优势是可以分别构建系统及子系统，而且更重要的是这些系统可以被独立测试和维护。</p>
<ul>
<li>稳定的复杂系统通常有一定的层级结构，每个系统由更简单的子系统构建而成，这些子系统又由更简单的子系统构建而成。组合适用于这条准则，即通过简单的对象来构造复杂的对象。</li>
<li>稳定的复杂系统是可分解的。</li>
<li>稳定的复杂系统往往由不同类型的子系统以不同的方式组合而成。</li>
<li>可工作的复杂系统往往是从可工作的简单系统演化而来。</li>
</ul>
<p>作为软件设计者，组合是用于对抗软件的复杂度的非常重要的策略之一。</p>
<p>使用组件的主要好处就是可以使用其他开发人员（甚至是第三方供应商）构建的组件。</p>
<p>通常有两种组合方式：联合和聚合。联合和聚合的微小区别在于部分如何构成整体。在聚合中，通常只看到整体，而在联合中，通常看到的是组成整体的部分。</p>
<p>最直观的组合方式就是聚合。聚合意味着复杂的对象由其他对象构成。</p>
<p>聚合代表你通常看到了整体，而联合既代表整体，也代表部分。在立体音响系统中，各种各样的组件是独立的，通过插接线（连接各种各样组件的线）连接成整体。</p>
<p>聚合是指复杂的对象由其他对象组成。而当一个对象需要其他对象的服务时则使用联合。</p>
<p>最佳实践是一个领域中的对象不应当和另一个领域中的对象混合，除非有非常特殊的情况。</p>
<p>利用混合系统的便利性是一项设计决策。如果TV/VCR集成系统的便利性比单个组件的风险和故障更重要，那么采用混合领域则是首选的设计决策。</p>
<p>基数表示参与联合的对象个数，可以表示这种联合关系是可以选还是强制的。</p>
<p>当处理联合时最重要的问题之一是确保设计应用程序时检查可选的联合。即代码必须检查该联合是否为 null。</p>
<p>类图有三部分组成：类名、属性和方法（构造函数也是方法）。</p>
<p>属性没有签名，有类型；方法具有签名。</p>
<p>通过类图可以知道参数的数据类型。因为属性之前有个减号（-）前缀，声明了这些属性是私有属性。加号（+）则表示这些属性是公共的，而这是不应该的。</p>
<p>在 Java 中访问修饰符的默认类型是受保护类型。</p>
<p>当需要借助其他类来创建一个类时就是组合关系。当一个类由其他类组成时就是聚合关系（比如轮胎和汽车的关系）。当一个类需要其他类的服务时就是联合关系（比如客户需要服务器的服务）。</p>
<p>聚合由一个头部有一个菱形的线表示。</p>
<p>在UML标记中，一条单纯的线表示这种关系，线的两端没有任何形状。</p>
<p>XML是一种标准的机制，可以在完全不同的系统之间定义和传输数据（JSON是另一种机制）。XML和JSON提供了一种在相互独立的应用程序之间共享数据的机制。</p>
<p>XML提供了以多种方式传输数据的标准。通常可以认为数据能够以垂直和水平两种范式来传输。词条垂直意味着数据可以跨行业传输。</p>
<p>采用XML标准的另一种方式是建立水平应用程序。水平的应用程序特定于某个行业。</p>
<p>XML全程为扩展标记语言。你可能早已熟悉另一种标记语言，叫作超文本标记语言（HTML）。XML 和 HTML 是 SGML 的后代，SGML 是标准的通用标记语言。</p>
<p>然而 XML 提供了两个 HTML 不具备的优势，就是验证文档以及格式化文档。</p>
<p>HTML 的标签是预定义的。</p>
<p>存在一种叫作文档类型定义的（DTD）的文档。DTD 用于定义描述数据的标签。当创建 XML 文档时，只可以使用预定义的标签。</p>
<p>你不必强制使用 DTD。但使用 DTD 可以验证 XML 文档。对 XML 的唯一验证方式就是检查 XML 的格式是否正确。而使用了 DTD 的 XML 则不接受最佳猜测。如果文档结构不正确，那么会产生一个错误，该文档是不合法的。</p>
<p>通常使用面向对象的语言开发的应用程序可以与 XML 进行交互。</p>
<p>XML 文档可以将 DTD 内嵌在文档中，也可以指定一个外部的 DTD。外部的 DTD 提供了一种更强大的机制。</p>
<p>PCDATA 全称为解析字符数据，是从文本文件中解析字符信息的标准。</p>
<p>早期的一个工具叫作 XML Notepad，它和微软操作系统提供的 Notepad 很相似，有助于我们理解 XML 文档的结构。</p>
<p>需要使用 XML 验证器来检查合法性。</p>
<p>w3schools 网站的 XML 验证器是其中之一，而且简单易用。</p>
<p>需要指出 HTML 不会进行这种类型的检查。事实上，即使 XML 文档结构是非法的，但仍然可以用浏览器打开。</p>
<p>请记住 XML 主要用于定义数据，而 HTML 则基本上是一种展示机制。它们都可以用于在浏览器中展示数据。</p>
<p>JavaScript 对象标记（又称为 JSON）更加灵活。</p>
<ul>
<li>JSON 是轻量级文本数据交换格式</li>
<li>JSON 与语言无关</li>
<li>JSON 是”自描述的“，并且容易理解</li>
</ul>
<p>JSON 使用 JavaScript 语法来描述数据对象，但 JSON 依然是语言和平台无关的。</p>
<p>JavaScript 程序可以使用内建的 eval() 函数来执行 JSON 数据并创建原生的 JavaScript 对象。</p>
<p>XML 和 JSON 共同目标是可以轻松解析、分享和使用包含在对象中的传输数据。很多人喜欢使用 JSON 是因为它的结构比 XML 简单，而且处理速度更快。</p>
<p>保存对象的状态以便以后使用，这一概念被称为持久化。我们使用术语持久化对象来定义一个不依赖与单个应用程序的对象，该对象可以被存储并稍后再次使用。</p>
<ul>
<li>保存到平面文件中</li>
<li>保存到关系型数据库中</li>
<li>保存到对象数据库中</li>
</ul>
<p>存储对象还要考虑的另一个问题是对象可以包含其他对象。</p>
<p>在上面 Java 序列化的例子中，方法并没有被显示保存。注意我们已经说明 Java 即用于存储对象，也用于恢复对象。事实上定义类时就限制了存储和恢复时对象的类型都必须是同一个类。因此方法自身无需保存到数据存储中。</p>
<p>公司如果使用对象数据库，则需要将所有数据从关系型数据库中转换到对象数据库中。这有很多缺点：</p>
<ul>
<li>第一，任何做过数据库间数据迁移的人都知道这事非常痛苦的过程。</li>
<li>第二。即使数据转换成功了，也没有任何方式知道数据库工具的改变将如何影响应用程序代码。</li>
<li>第三，当发生问题时（这种情况经常发生），很难确定是数据库导致的问题还是应用程序代码导致的问题。</li>
</ul>
<p>作为专业开发人员的最酷的现实之一是改变永无止境。</p>
<p>电子邮件的出现揭示了”分布式计算“这一概念。</p>
<p>我们已经说过C++不是真正的面向对象的编程语言，而是基于对象的编程语言。</p>
<p>注意任何 Web 应用都需要在客户端和服务器做验证，因为在客户端有方式可以绕过客户端验证直接向服务器发送数据，或者用户可以直接禁用客户端脚本而发送非法值。解决该问题有几个关键点需要考虑：</p>
<ul>
<li>向服务器端发送信息需要更多的时间成本。</li>
<li>向服务器端发送信息会增加网络传输。</li>
<li>向服务器端发送信息会占用服务器资源。</li>
<li>向服务器端发送信息会存在潜在的错误。</li>
</ul>
<p>基于这些原因以及其他潜在的问题，最终目标是在客户端进行尽可能多的验证。</p>
<p>JavaScript 和大多数脚本语言都是基于对象的。可以认为脚本语言是传统的编程范式和面向对象范式之间的桥梁。</p>
<p>客户端 JavaScript 通常存活在浏览器作用域中。</p>
<p>尽管 Java 和 JavaScript 都基于 C 语法，但他们没有什么直接关系。</p>
<p>很多对象类型可以直接内置到HTML文档中。网页控制器由一组预先构建的对象组成。可以使用<code>&lt;object&gt;</code>标签来使用这些对象。<code>&lt;object&gt;</code>标签也可以用于在浏览器中内置和启动各种音乐播放器。启动的播放器类型取决于浏览器加载的默认播放器。</p>
<p>对企业计算最基本的定义是它本质上是分布式计算。分布式计算文如其名，指一组分布式的计算机通过网络一起工作。分布式计算的力量在于计算机可以共享网络。</p>
<p>企业系统都是基于分布式对象构建的。使用分布式对象有很多优势。最大优势是理论上系统可以调用处于网络任何位置的对象。这是一种非常强大的能力，而且是当今基于互联网的业务的基石。另一个主要优势是可以通过网络中的多台服务器分发系统服务。</p>
<p>我们使用W3C提供的对Web服务的通用定义，即”客户端和服务器端使用基于SOAP（simple object access protocol，简单对象访问协议）标准的XML消息进行通信”。</p>
<p>SOAP是一项通信协议，用于通过互联网发送消息。我们可以描述SOAP为：SOAP是基于XML的用于分布式应用程序的协议。</p>
<p>远程程序调用（RPC）是一个通信机制，允许通过共享的网络调用其他计算机上的服务（对象）。</p>
<p>这种方式叫作表征状态转移，也叫作ReST。ReST 是一种无状态的协议，基本上依赖于HTTP。由于HTTP是互联网自身的基石，很大程度上可以说互联网的架构基于ReST，这通常称为RESTful架构。</p>
<p>软件开发的有趣之处在于，当设计软件系统时，实际上是在对现实世界系统进行建模。</p>
<p>设计模式归为三类，分别是创建型模式、结构型模式和行为型模式。</p>
<ul>
<li>模式名称，使用一到两个词语来描述一个设计问题、对应的解决方案以及后果。</li>
<li>适用于该模式的待解决的问题，需要解释该问题的详细内容。</li>
<li>解决方案，描述了设计方案，比如类与对象之间的关系，各自的职责和协作等。</li>
<li>效果，效果是指应用该模式的结果以及利弊。</li>
</ul>
<p>模型是应用程序对象，视图是屏幕显示，控制器则定义了用户接口如何响应用户输入。</p>
<ul>
<li>创建型模式。帮你创建对象，你无需直接实例化对象。你可以根据给定的条件创建对象，这给程序带来更大的灵活性。</li>
<li>结构型模式。将一组对象组合更复杂的结构，比如复杂的用户接口或者账单数据。</li>
<li>行为型模式。定义系统中对象之间的通信方式，控制复杂程序中的流向。</li>
</ul>
<p>创建型模式包含以下模式：</p>
<ul>
<li>抽象工厂模式</li>
<li>构造器模式</li>
<li>工厂方法模式</li>
<li>原型模式</li>
<li>单例模式</li>
</ul>
<p>请记住面向对象的重要规则之一是对象的职责由自身管理。</p>
<p>结构型模式用于使用一组对象来创建更复杂的结构，包括：</p>
<ul>
<li>适配器模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>装饰器模式</li>
<li>外观模式</li>
<li>轻量模式</li>
<li>代理模式</li>
</ul>
<p>行为型模式包含以下类别：</p>
<ul>
<li>责任链模式</li>
<li>命令模式</li>
<li>解释器模式</li>
<li>迭代器模式</li>
<li>中介者模式</li>
<li>备忘录模式</li>
<li>观察者模式</li>
<li>状态模式</li>
<li>策略模式</li>
<li>模板方法模式</li>
<li>访问者模式</li>
</ul>
<p>设计模式是从有益的经验中总结出来的，反模式则来自于失败的经验。大多数软件项目最终不成功的原因都会被记载下来，最终总结为反模式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
      <category term="Reading Notes" scheme="https://zhulichao.github.io/categories/Reading-Notes/"/>
    
    
      <category term="Reading Notes" scheme="https://zhulichao.github.io/tags/Reading-Notes/"/>
    
  </entry>
  
  <entry>
    <title>组件拆分、设计</title>
    <link href="https://zhulichao.github.io/2020/09/26/component-splitting/"/>
    <id>https://zhulichao.github.io/2020/09/26/component-splitting/</id>
    <published>2020-09-26T01:35:53.000Z</published>
    <updated>2021-08-11T08:16:24.297Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h2><ul>
<li>各种名称要尽量语义化、规范化，如组件名、参数名、方法名，语义化可以起到注释的作用，规范化保证系统各处命名规则一致</li>
<li>必要的容错处理，如没传参数、参数不正确等</li>
<li>常用的设置可以提取为缺省值</li>
<li>尽量提取出配置项，可预留用户自己定义内容的地方</li>
<li>场景化，如 dialog 的 success、warning 状态</li>
<li>可以拆分出子组件但不用过度组件化，适当的时候再分离也可以，维护良好的层次结构，可借助 StarUML 等工具画出组件图</li>
<li>扁平化、面向数据的 state/props，更加纯粹的 state 变化，这也是Redux推崇的，完全的扁平化设计能带来的开发体验和性能提升</li>
<li>考虑集中、统一的状态管理</li>
<li>提前考虑可扩展性，尽量做到后面的改变能向下兼容</li>
<li>分阶段、多版本维护，没必要一次就完成全部功能</li>
<li>维护详细的 CHANGELOG 或其它文档，能够记录变更历史</li>
<li>辅助代码分离，提取配置代码、假数据、非技术说明文档等</li>
</ul>
<h2 id="组件化规范"><a href="#组件化规范" class="headerlink" title="组件化规范"></a>组件化规范</h2><ul>
<li>组件之间独立、松耦合</li>
<li>组件间嵌套使用</li>
<li>组件间通信</li>
<li>组件公用部分设计</li>
<li>组件的构建打包</li>
<li>组件继承与复用性</li>
<li>私有组件的统一管理</li>
<li>根据特性场景进行扩展或自定义</li>
</ul>
<h2 id="组件拆分"><a href="#组件拆分" class="headerlink" title="组件拆分"></a>组件拆分</h2><h3 id="拆分依据"><a href="#拆分依据" class="headerlink" title="拆分依据"></a>拆分依据</h3><ul>
<li>通常一个工程，由多个模块组成，每个模块由多个组件构成</li>
<li>可复用性，基础组件，方便统一管理，src/components</li>
<li>可维护性，拆分的依据一般是单一原则，分而治之，降低复杂度，src/views/xxx/components</li>
<li>可测试性，耦合度低到一定程度就可以了，没必要再无限制的拆分下去</li>
<li>适应UI设计师的建模</li>
<li>方便协作，有人控制逻辑，有人只写展示组件</li>
<li>不拆分是否有性能影响，使拆分后的组件更容易判断是否更新</li>
<li>考虑拆分的好处是否超过了成本</li>
</ul>
<h3 id="拆分方式"><a href="#拆分方式" class="headerlink" title="拆分方式"></a>拆分方式</h3><ul>
<li>区分展示组件和容器组件，展示组件，通常没有自己的状态，只为展示信息，容器组件，有自己的状态、逻辑处理、数据绑定等，通常调用展示组件</li>
<li>切割复杂的 render() 方法，创建子组件</li>
<li>模板化组件，固定的东西放在模板组件中，业务组件进行逻辑处理后调用模板组件</li>
<li>高阶组件，做一层封装返回新组件</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
    
    </summary>
    
      <category term="React" scheme="https://zhulichao.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://zhulichao.github.io/tags/React/"/>
    
  </entry>
  
</feed>
